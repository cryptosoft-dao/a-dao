#include "stdlib.fc";

;; Operation Codes

const int op::process_deploy_message = 0;
const int op::master_log = 1;
const int op::activate_a_dao = 2;
const int op::propose_transaction = 3;
const int op::approve_transaction = 4;
const int op::accept_invitation_to_a_dao = 5;
const int op::buy_points = 6;
const int op::invite_to_a_dao = 7;
const int op::change_my_address = 8;
const int op::quit_a_dao = 9;

;; Transaction Types

const int tt::transaction_without_type = 0;
const int tt::invite_address = 1;
const int tt::delete_address = 2;
const int tt::withdraw_profit = 3;
const int tt::distribute_ton = 4;
const int tt::arbitrary_transaction = 5;
const int tt::update_agreement_percent = 6;
const int tt::transfer_points = 7;
const int tt::put_up_points_for_sale = 8;
const int tt::delete_pending_invitations = 9;
const int tt::delete_pending_transactions = 10;

;; Storage globals

    ;; Initial

    global int active?; ;; uint1
    global slice a_dao_master; ;; slice 257bits
    global slice deployer_address; ;; slice 257bits
    global int transaction_fee; ;; uint32

    ;; Active

    global int agreement_percent_numerator; ;; int32
    global int agreement_percent_denominator; ;; int32
    global int profit_reserve_percent_numerator; ;; int32
    global int profit_reserve_percent_denominator; ;; int32
    ;; udict profitable_addresses
        ;; Key: uint32
        ;; value (cell)
            ;; slice profitable_address
    global cell profitable_addresses;
    ;; udict pending_invitations
        ;; Key: uint32
        ;; value (cell)
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
    global cell pending_invitations; ;; on activation
    ;; udict pending_transactions
        ;; Key: uint32
        ;; value (cell)
            ;; int4 transaction_type
            ;; int32 deadline
            ;; cell transaction_info
            ;; cell approves
            ;; int32 approval_points_recieved
    global cell pending_transactions;
    ;; udict authorized_addresses
        ;; Key: uint32
        ;; value (slice)
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
    global cell authorized_addresses;
    global int total_approval_points; ;; uint32
    global int total_profit_points; ;;uint32
    global int total_profit_reserved;

;; Storage functions

() save_data() impure inline {
    ~strdump("Start save_data()");
    set_data(
        begin_cell()
            .store_int(active?, 1)
            .store_slice(a_dao_master)
            .store_slice(deployer_address)
            .store_uint(transaction_fee, 32)
            .store_uint(agreement_percent_numerator, 32)
            .store_uint(agreement_percent_denominator, 32)
            .store_uint(profit_reserve_percent_numerator, 32)
            .store_uint(profit_reserve_percent_denominator, 32)
            .store_dict(profitable_addresses)
            .store_dict(pending_invitations)
            .store_dict(pending_transactions)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_profit_points, 32)
            .store_uint(total_profit_reserved, 32)
        .end_cell()
    );
    ~strdump("End save_data()");
}

() load_data() impure inline { 

    ~strdump("Start load_data()");

    slice ds = get_data().begin_parse();
    active? = ds~load_int(1);
    a_dao_master = ds~load_msg_addr();
    deployer_address = ds~load_msg_addr();

    if (active? == false) {

        ~strdump("active? == false");

        transaction_fee = 0;
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;
        profit_reserve_percent_numerator = 0; 
        profit_reserve_percent_denominator = 0;
        profitable_addresses = new_dict();
        pending_invitations = new_dict();
        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0; 
        total_profit_reserved = 0;

    } else {

        ~strdump("active? == true");

        transaction_fee = ds~load_uint(32);
        agreement_percent_numerator = ds~load_uint(32);
        agreement_percent_denominator = ds~load_uint(32);
        profit_reserve_percent_numerator = ds~load_uint(32); 
        profit_reserve_percent_denominator = ds~load_uint(32);
        profitable_addresses = ds~load_dict();
        pending_invitations = ds~load_dict();
        pending_transactions = ds~load_dict();
        authorized_addresses = ds~load_dict();
        total_approval_points = ds~load_uint(32);
        total_profit_points = ds~load_uint(32); 
        total_profit_reserved = ds~load_uint(32);
        ds.end_parse();

    }

    ~strdump("End load_data()");

}

() just_notify_master(int op, int transaction_type) impure inline {

    cell msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(a_dao_master)
        .store_coins(transaction_fee)
        .store_uint(1, 107)
        .store_ref(
            begin_cell()
                .store_uint(op, 32)
                .store_uint(transaction_type, 32)
            .end_cell()
        )
    .end_cell();

    send_raw_message(msg, 1);

}

() send_invites_to_a_dao(cell pending_invitations) impure inline {

    ~strdump("Start sending invites to A DAO");

    (int passcode, cell authorized_address_info, int flag) = pending_invitations.udict_get_min_ref?(32);

    while (flag) {

        slice authorized_address_info_cs = authorized_address_info.begin_parse();

        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        int approval_points = authorized_address_info_cs~load_uint(32);
        int profit_points = authorized_address_info_cs~load_uint(32);

        cell msg = 
            begin_cell()
                .store_uint(0x18, 6)
                .store_slice(authorized_address)
                .store_coins(30000000) ;; check on tests
                .store_uint(1, 107)
                .store_ref(
                    begin_cell()
                        .store_uint(op::invite_to_a_dao, 32)
                        .store_uint(passcode, 32)
                        .store_uint(approval_points, 32)
                        .store_uint(profit_points, 32)
                    .end_cell()
                )
            .end_cell();

        send_raw_message(msg, 0);

        passcode += 1;

        (authorized_address_info, flag) = pending_invitations.udict_get_ref?(32, passcode);

        active? = true;
        
    }

    ~strdump("Terminate sending invites to A DAO");

}

() clear_pending_transactions_queue(cell pending_transactions) inline {

    (int key, slice transaction_info, int success?) = pending_transactions.udict_get_min?(256);

    while (success?) {
        (key, transaction_info, success?) = pending_transactions.udict_get_next?(256, key);

        transaction_info~skip_bits(8); ;; skip transaction_type
        transaction_info~load_uint(32); ;; deadline
    }

}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::approve_transaction) {

        ~strdump("Start transaction approval");

        int passcode = in_msg_body~load_uint(32);
        passcode~dump();
        int transaction_index = in_msg_body~load_uint(32);
        transaction_index~dump();

        ~strdump("Start sender authorization");

        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(32, passcode);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        success?~dump();
        throw_unless(222, success? & equal_slices(sender_address, authorized_address));

        ~strdump("Start points parsing");

        int approval_points = authorized_address_info_cs~load_uint(32);
        int profit_points = authorized_address_info_cs~load_uint(32);

        ~strdump("Get transaction by transaction_index");

        (cell transaction, int flag) = pending_transactions.udict_get_ref?(32, transaction_index);
        throw_unless(200, flag);

        ~strdump("Parse transaction");

        slice transaction_cs = transaction.begin_parse();

        int transaction_type = transaction_cs~load_uint(32); ;; transaction_type
        transaction_type~dump();
        int deadline = transaction_cs~load_uint(32); ;; deadline
        cell transaction_info = transaction_cs~load_ref(); ;; transaction_info
        cell approves = transaction_cs~load_dict(); ;; approves
        int approval_points_recieved = transaction_cs~load_uint(32); ;; approval_points_recieved

        ~strdump("Add approve to approves dictionary");

        int success? = approves~udict_add?(32, passcode, transaction_cs);

        ~strdump("Count approves");

        int approves_for_approval = total_approval_points * agreement_percent_numerator / agreement_percent_denominator;
        approval_points_recieved = approval_points_recieved + approval_points;

        ~strdump("Delete old transaction state from pending_transactions");

        (pending_transactions, int flag) = pending_transactions.udict_delete?(32, transaction_index);
        throw_unless(666, flag);

        ~strdump("Start check if sufficient approves to start actions");

        if (approval_points_recieved > approves_for_approval) {

            slice transaction_info_cs = transaction_info.begin_parse();

            ;; Do pending_transactions

            if (transaction_type == tt::invite_address) {

                ~strdump("Start Transaction Approval: Invite Address");

                (int last_passcode, _, _) = pending_invitations.udict_get_max_ref?(32);
                int passcode = last_passcode + 1;

                slice authorized_address = transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                int profit_points = transaction_info_cs~load_uint(32); ;; int profit_points

                ~strdump("Add address to pending invitations");

                pending_invitations~udict_set_ref(32, passcode, transaction_info);

                ~strdump("Send invitation to authorized_address");

                cell msg = 
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(authorized_address)
                        .store_coins(30000000) ;; check on tests
                        .store_uint(1, 107)
                        .store_ref(
                            begin_cell()
                                .store_uint(op::invite_to_a_dao, 32)
                                .store_uint(passcode, 32)
                                .store_uint(approval_points, 32)
                                .store_uint(profit_points, 32)
                            .end_cell()
                        )
                    .end_cell();

                send_raw_message(msg, 0);

                save_data();
                just_notify_master(op, transaction_type);
                return();

            }

            if (transaction_type == tt::delete_address) {

                ~strdump("Start Transaction Approval: Delete Address");

                int passcode_to_delete = transaction_info_cs~load_uint(32);

                ~strdump("Decrease total points");

                (slice authorized_address_info_cs, int flag) = authorized_addresses.udict_get?(32, passcode_to_delete);
                authorized_address_info_cs~load_msg_addr(); ;; slice authorized_address
                int approval_points = authorized_address_info_cs~load_uint(32);
                int profit_points = authorized_address_info_cs~load_uint(32);

                total_approval_points = total_approval_points - approval_points;
                total_profit_points = total_profit_points - profit_points;

                ~strdump("Delete address from dict");

                (authorized_addresses, int flag) = authorized_addresses.udict_delete?(32, passcode_to_delete);

                save_data();
                total_approval_points~dump();
                total_profit_points~dump();
                just_notify_master(op, transaction_type);
                return();

            }

            ;; Send transaction to dApp for profit withdrawal
            if (transaction_type == tt::withdraw_profit) {

                ~strdump("Start Transaction Approval: Withdraw Profit");

                int profitable_address_passcode = transaction_info_cs~load_uint(32);
                (cell profitable_address_info, int flag) = profitable_addresses.udict_get_ref?(32, profitable_address_passcode);
                throw_unless(222, flag);
                slice profitable_address_info_cs = profitable_address_info.begin_parse();
                slice profitable_address = profitable_address_info_cs~load_msg_addr();

                var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(profitable_address)
                    .store_coins(330000000)
                    .store_uint(1, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(48, 32) ;; int32 op::withdraw_funds
                        .end_cell()
                    )
                .end_cell();

                send_raw_message(msg, 0);

                save_data();
                just_notify_master(op, transaction_type);
                return();

            }

            if (transaction_type == tt::distribute_ton) {

                ~strdump("Start Transaction Approval: Distribute Ton");

                int ton_to_distribute = transaction_info_cs~load_coins(); ;; int amount

                ~strdump("Start sending TON to authorized addresses");

                (int key, slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get_min?(32);

                ~strdump("Start sending TON to authorized addresses");

                while (success?) {

                    ~strdump("In while cycle");

                    slice address = authorized_address_info_cs~load_msg_addr();
                    int approval_points = authorized_address_info_cs~load_uint(32);
                    int profit_points = authorized_address_info_cs~load_uint(32);

                    int ton_amount_to_address = ton_to_distribute / total_profit_points * profit_points;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(ton_amount_to_address)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);

                    (key, authorized_address_info_cs, success?) = authorized_addresses.udict_get_next?(32, key);

                }

                save_data();
                just_notify_master(op, transaction_type);
                return();

            }

            if (transaction_type == tt::arbitrary_transaction) {

                ~strdump("Start Transaction Approval: Arbitrary Transaction");

                slice destination = transaction_info_cs~load_msg_addr(); ;; destination
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body

                throw_if(666, amount > my_balance - total_profit_reserved);

                ;; Arbitrary transtransaction

                var msg = 
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(destination)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();

                send_raw_message(msg, 0);

                save_data();
                just_notify_master(op, transaction_type);
                return();

            }

            if (transaction_type == tt::update_agreement_percent) {

                ~strdump("Start Transaction Approval: Update Agreement Percent");

                agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; parse and save new settings
                agreement_percent_denominator = transaction_info_cs~load_uint(32);

                save_data();
                just_notify_master(op, transaction_type);
                return();

            }

            if (transaction_type == tt::transfer_points) {

                ~strdump("Start Transaction Approval: Transfer Points");

                ~strdump("Delete address from authorized_addresses if all points transfered");

                save_data();
                just_notify_master(op, transaction_type);
                return();
                
            }

            if (transaction_type == tt::put_up_points_for_sale) {

            }

            if (transaction_type == tt::delete_pending_invitations) {

            }

            if (transaction_type == tt::delete_pending_transactions) {

            }

        } else {

            ~strdump("Save new transaction state if not sufficient points for actions");

            cell new_transaction_state = begin_cell()
                .store_uint(transaction_type, 32)
                .store_uint(deadline, 32)
                .store_ref(transaction_info)
                .store_dict(approves)
                .store_uint(approval_points_recieved, 32)
            .end_cell();

            pending_transactions~udict_set_ref(32, transaction_index, new_transaction_state);
        
        }

            save_data();
            just_notify_master(op, tt::transaction_without_type);
            return();

    }

    ;; start transaction msg: int passcode, int transaction_index, cell transaction_cell

    if (op == op::propose_transaction) {

        ~strdump("Start transaction proposal");

        ;; Check if sender is an authorized routing pool wallet

        int passcode = in_msg_body~load_uint(32);

        ~strdump("Start proposal initiator authorization");

        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(32, passcode);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        throw_unless(222, success? & equal_slices(sender_address, authorized_address));

        ~strdump("Start proposal parsing");

        int transaction_type = in_msg_body.preload_uint(32);
        transaction_type~dump();
        int deadline = in_msg_body.preload_uint(32);
        cell transaction_info = in_msg_body.preload_ref();

        ~strdump("Get max pending_transactions index");

        (int max_transaction_index, _, int flag) = pending_transactions.udict_get_max?(32);

        if (~ flag) {
            max_transaction_index = -1;
        }

        max_transaction_index~dump();

        ~strdump("Convert transaction_info to slice");

        slice transaction_info_cs = transaction_info.begin_parse();

        ~strdump("Set zero approves");

        cell approves = new_dict();
        int approval_points_recieved = 0;

        if (transaction_type == tt::invite_address) {

            ~strdump("Start Proposal: Invite Address");

            transaction_info_cs~load_msg_addr(); ;; slice address_to_invite
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int profit_points

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::delete_address) {

            ~strdump("Start Transaction Proposal: Delete Address");

            transaction_info_cs~load_uint(32); ;; int passcode_to_delete

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::withdraw_profit) {

            ~strdump("Start Transaction Proposal: Withdraw Profit");

            transaction_info_cs~load_uint(32); ;; int profitable_address_passcode

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::distribute_ton) {

            ~strdump("Start Transaction Proposal: Distribute Ton");

            transaction_info_cs~load_coins(); ;; int distribution_amount

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::arbitrary_transaction) {

            ~strdump("Start Transaction Proposal: Arbitrary Transaction");

            transaction_info_cs~load_msg_addr(); ;; destination
            int amount = transaction_info_cs~load_coins(); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body

            ~strdump("Check the integrity of reserves");

            throw_if(666, amount > my_balance - total_profit_reserved);

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::update_agreement_percent) {

            ~strdump("Start Transaction Proposal: Update Agreement Percent");

            transaction_info_cs~load_uint(32); ;; int agreement_percent_numerator
            transaction_info_cs~load_uint(32); ;; int agreement_percent_denominator

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::transfer_points) {

            ~strdump("Start Transaction Proposal: Transfer Points");

            transaction_info_cs~load_msg_addr(); ;; slice destination
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int profit_points

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approves)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );

            save_data();
            just_notify_master(op, transaction_type);
            return();

        }

        if (transaction_type == tt::put_up_points_for_sale) {

        }

        if (transaction_type == tt::delete_pending_invitations) {

        }

        if (transaction_type == tt::delete_pending_transactions) {

        }

    }

    if (op == op::change_my_address) {

        ~strdump("Start changing my address");

        int passcode = in_msg_body~load_uint(32);
        slice new_authorized_address = in_msg_body~load_msg_addr();
        (slice authorized_address_info_cs, int flag) = authorized_addresses.udict_get?(32, passcode);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("Start authorized_address update");

            slice new_authorized_authorized_address_info = 
                begin_cell()
                    .store_slice(new_authorized_address)
                    .store_uint(approval_points, 32)
                    .store_uint(profit_points, 32)
                .end_cell().begin_parse();

            authorized_addresses~udict_set(32, passcode, new_authorized_authorized_address_info);

        }

        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();

    }

    if (op == op::quit_a_dao) {

        ~strdump("Start quiting A DAO");

        int passcode = in_msg_body~load_uint(32);
        (slice authorized_address_info_cs, int flag) = authorized_addresses.udict_get?(32, passcode);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("Start authorized_address removal");

            (authorized_addresses, int flag) = authorized_addresses.udict_delete?(32, passcode);
            throw_unless(666, flag);

            ~strdump("Start points update");

            total_approval_points -= approval_points;
            total_profit_points -= profit_points;

            total_approval_points~dump();
            total_profit_points~dump();

        }

        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();

    }

    if (op == op::accept_invitation_to_a_dao) {

        ~strdump("Start accepting invitation to A DAO");

        int passcode = in_msg_body~load_uint(32);
        (cell authorized_address_info, int flag) = pending_invitations.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("End authorized_address adding");

            authorized_addresses~udict_set(32, passcode, authorized_address_info.begin_parse());

            ~strdump("Start points update");

            total_approval_points += approval_points;
            total_profit_points += profit_points;

            total_approval_points~dump();
            total_profit_points~dump();

        }

        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();

    }

    if (op == op::activate_a_dao) {

        ~strdump("Start A DAO Activation");

        throw_unless(333, equal_slices(sender_address, deployer_address));

        active? = true;
        agreement_percent_numerator = in_msg_body~load_uint(32);
        agreement_percent_denominator = in_msg_body~load_uint(32);
        profit_reserve_percent_numerator = in_msg_body~load_uint(32);
        profit_reserve_percent_denominator = in_msg_body~load_uint(32);
        profitable_addresses = in_msg_body~load_dict();
        pending_invitations = in_msg_body~load_dict();

        send_invites_to_a_dao(pending_invitations);

        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();

    }

    ;; Internal method of protocol

    if (op == op::process_deploy_message) {

        ~strdump("Start deploy message processing");

        throw_unless(666, equal_slices(sender_address, a_dao_master));
        transaction_fee = in_msg_body~load_uint(32);
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;

        if (slice_bits(in_msg_body) > 0) { ;; If config added with deploy message

            agreement_percent_numerator = in_msg_body~load_uint(32);
            agreement_percent_denominator = in_msg_body~load_uint(32);
            pending_invitations = in_msg_body~load_dict();

            send_invites_to_a_dao(pending_invitations);

        }

        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0;

        active? = false;

        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();

    }

    throw(0xffff);

}

;; Custom get-methods

(int, slice, slice, int, int, int, int, int, cell, cell, cell, cell, int, int, int) get_a_dao_data() method_id {

    load_data();

    return (
        active?, ;; int1
        a_dao_master, ;; slice
        deployer_address, ;; slice
        transaction_fee, ;; uint32
        agreement_percent_numerator, ;; uint32
        agreement_percent_denominator, ;; uint32
        profit_reserve_percent_numerator, ;; uint32
        profit_reserve_percent_denominator, ;; uint32
        profitable_addresses,
        pending_invitations, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int profit_points
        pending_transactions, ;; key: uint10 // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approval_points_recieved
        authorized_addresses, ;; key: int address_sha256_hash // value (slice): slice address,  int approval_points, int profit_points
        total_approval_points, ;; uint32
        total_profit_points, ;; uint32
        total_profit_reserved ;; uint32
    );

}