#include "stdlib.fc";
#include "op.fc";
#include "transactions_types.fc";

;; Storage globals

    ;; Initial

    global int active?; ;; uint1
    global slice root_address; ;; slice 257bits ;; initial state
    global slice deployer_address; ;; slice 257bits ;; initial state
    global int transaction_fee; ;; uint32

    ;; Active

    global int agreement_percent_numerator; ;; int32
    global int agreement_percent_denominator; ;; int32
    global int profit_reserve_percent_numerator; ;; int32
    global int profit_reserve_percent_denominator; ;; int32
    ;; udict profitable_addresses
        ;; Key: uint256 hash(address)
        ;; value: slice profitable_address
    global cell profitable_addresses;
    ;; udict pending_invitations
        ;; Key: uint32
        ;; value
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
    global cell pending_invitations; ;; on activation
    ;; udict pending_transactions
        ;; Key: uint32
        ;; value (cell)
            ;; int4 transaction_type
            ;; int32 deadline
            ;; cell transaction_info
            ;; cell approves
            ;; int32 approve_points
    global cell pending_transactions;
    ;; udict authorized_addresses
        ;; Key: uint256 hash(address)
        ;; value (Slice)
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
    global cell authorized_addresses;
    global int total_approval_points; ;; uint32
    global int total_profit_points; ;;uint32
    global int total_profit_reserved;

;; Storage functions

() save_data() impure inline {
    ~strdump("Start save_data()");
    set_data(
        begin_cell()
            .store_int(active?, 1)
            .store_slice(root_address)
            .store_slice(deployer_address)
            .store_uint(transaction_fee, 32)
            .store_uint(agreement_percent_numerator, 32)
            .store_uint(agreement_percent_denominator, 32)
            .store_uint(profit_reserve_percent_numerator, 32)
            .store_uint(profit_reserve_percent_denominator, 32)
            .store_dict(profitable_addresses)
            .store_dict(pending_invitations)
            .store_dict(pending_transactions)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_profit_points, 32)
            .store_uint(total_profit_reserved, 32)
        .end_cell()
    );
    ~strdump("End save_data()");
}

() load_data() impure inline { 

    ~strdump("Start load_data()");

    slice ds = get_data().begin_parse();
    active? = ds~load_int(1);
    root_address = ds~load_msg_addr();
    deployer_address = ds~load_msg_addr();

    if (active? == false) {

        ~strdump("active? == false");

        transaction_fee = 0;
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;
        profit_reserve_percent_numerator = 0; 
        profit_reserve_percent_denominator = 0;
        profitable_addresses = new_dict();
        pending_invitations = new_dict();
        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0; 
        total_profit_reserved = 0;

    } else {

        ~strdump("active? == true");

        transaction_fee = ds~load_uint(32);
        agreement_percent_numerator = ds~load_uint(32);
        agreement_percent_denominator = ds~load_uint(32);
        profit_reserve_percent_numerator = ds~load_uint(32); 
        profit_reserve_percent_denominator = ds~load_uint(32);
        profitable_addresses = ds~load_dict();
        pending_invitations = ds~load_dict();
        pending_transactions = ds~load_dict();
        authorized_addresses = ds~load_dict();
        total_approval_points = ds~load_uint(32);
        total_profit_points = ds~load_uint(32); 
        total_profit_reserved = ds~load_uint(32);
        ds.end_parse();

    }

    ~strdump("End load_data()");

}

() clear_pending_transactions_queue(cell pending_transactions) inline {

    (int key, slice transaction_info, int success?) = pending_transactions.udict_get_min?(256);

    while (success?) {
        (key, transaction_info, success?) = pending_transactions.udict_get_next?(256, key);

        transaction_info~skip_bits(8); ;; skip transaction_type
        transaction_info~load_uint(32); ;; deadline
    }

}

() send_invites_to_a_dao(cell pending_invitations) impure inline {

}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::approve_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        int passcode = in_msg_body~load_uint(8);
        int transaction_index = in_msg_body~load_uint(8);

        ;; get transaction by transaction_index

        (slice transaction, int flag) = pending_transactions.udict_get?(32, transaction_index);
        throw_unless(200, flag);

        ;; Parse transaction

        int transaction_type = transaction~load_uint(4); ;; transaction_type
        int deadline = transaction~load_uint(32); ;; deadline
        cell transaction_info = transaction~load_ref(); ;; transaction_info
        cell approves = transaction~load_ref(); ;; approves
        int approve_points = transaction~load_uint(32); ;; approve_points

        ;; add approve

        int success? = approves~udict_add?(8, passcode, transaction);

        ;; get info about address from authorized_addresses

        (slice authorized_address_info, int success?) = authorized_addresses.udict_get?(8, passcode);
        throw_unless(111, success?); ;; throw if there is not such a address

        slice address = authorized_address_info~load_msg_addr();
        int approval_points = authorized_address_info~load_uint(32);
        int profit_points = authorized_address_info~load_uint(32);

        ;; Calculate new total transaction

        int new_approve_points = approve_points + approval_points;

        int approves_for_approval = total_approval_points / agreement_percent_denominator * agreement_percent_numerator;

        ;; Do pending_transactions in case of approval, otherwise save approve

        if (new_approve_points > approves_for_approval) {

            slice transaction_info_cs = transaction_info.begin_parse();

            ;; Do pending_transactions

            if (transaction_type == tt::invite_address) {

                (int last_passcode, _, _) = pending_transactions.udict_get_max?(8);
                int new_passcode = last_passcode + 1;

                transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                transaction_info_cs~load_uint(32); ;; int profit_points

                ;; Add new address to dict

                authorized_addresses~udict_add?(8, new_passcode, transaction_info_cs);

                ;; Increase total approves

                total_approval_points += approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::delete_address) {

                int address_to_delete_index = transaction_info_cs~load_uint(8);

                ;; Delete address from dict

                authorized_addresses.udict_delete?(8, address_to_delete_index);

                ;; Decrease total approves

                total_approval_points -= approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::withdraw_profit) {

                int ton_to_route = transaction_info_cs~load_uint(32); ;; int amount

                ;; Route ton

                (int key, slice authorized_address_info, int success?) = authorized_addresses.udict_get_min?(64);

                while (success?) {

                    slice address = authorized_address_info~load_msg_addr();
                    int approval_points = authorized_address_info~load_uint(32);
                    int profit_points = authorized_address_info~load_uint(32);

                    int ton_amount_to_address = ton_to_route / total_profit_points * profit_points;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(ton_amount_to_address)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);
                }

                save_data();
                return ();

            }

            ;; Send transaction to dApp for profit withdrawal

            if (transaction_type = tt::withdraw_profit) {

                slice profitable_address = transaction_info_cs~load_msg_addr();

                var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(profitable_address)
                    .store_coins(330000000)
                    .store_uint(1, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(48, 32) ;; int32 op::withdraw_funds
                        .end_cell()
                    )
                .end_cell();

                send_raw_message(msg, 0);

            }

            if (transaction_type == tt::arbitrary_transaction) {

                slice destination = transaction_info_cs~load_msg_addr(); ;; destination
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body

                throw_if(666, amount > my_balance - total_profit_reserved);

                ;; Arbitrary transtransaction

                var msg = 
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(destination)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();

                send_raw_message(msg, 0);

                save_data();
                return ();

            }

            if (transaction_type == tt::update_agreement_percent) {

                agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; parse and save new settings
                agreement_percent_denominator = transaction_info_cs~load_uint(32);

                save_data();
                return ();

            }

            if (transaction_type == tt::transfer_points) {
                
            }

        } else {

            approves~udict_add?(8, transaction_index, transaction);
        }

    }

    ;; start transaction msg: int passcode, int transaction_index, cell transaction_cell

    if (op == op::propose_transaction) {

        ~strdump("Start transaction proposal");

        ;; Check if sender is an authorized routing pool wallet

        int passcode = in_msg_body~load_uint(32);

        ~strdump("Start proposal initiator authorization");

        (cell authorized_address_info, int success?) = authorized_addresses.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        throw_unless(222, success? & equal_slices(sender_address, authorized_address));

        ~strdump("Start proposal parsing");

        int transaction_type = in_msg_body.preload_uint(32);
        int deadline = in_msg_body.preload_uint(32);
        cell transaction_info = in_msg_body.preload_ref();

        ~strdump("Get max pending_transactions index");

        (int transaction_index, _, int flag) = pending_transactions.udict_get_max?(32);

        if (~ flag) {
            transaction_index = 0;
        }

        ~strdump("Convert transaction_info to slice");

        slice transaction_info_cs = transaction_info.begin_parse();

        ~strdump("Set zero approves");

        cell approves = new_dict();
        int approve_points = 0;

        ;; Index 0: Add address
        ;; transaction_info: slice address_to_add_addr

        if (transaction_type == tt::invite_address) {

            ~strdump("Start Transaction Type: Invite Address");

            transaction_info_cs~load_msg_addr(); ;; slice address_to_invite
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int profit_points

            ~strdump("Add transaction to pending_transactions");

            pending_transactions~udict_set_ref(
                32, 
                transaction_index, 
                begin_cell()
                    .store_slice(in_msg_body)
                    .store_dict(approves)
                    .store_uint(approve_points, 32)
                .end_cell()
            );

            save_data();
            return ();

        }

        ;; Index 1: Eliminate address
        ;; transaction_info: slice address_to_eliminate_addr

        if (transaction_type == tt::delete_address) {

            ;; Check transaction_info for initiating termination of authority

            transaction_info_cs~load_msg_addr(); ;; slice address_to_eliminate_addr

            pending_transactions~udict_set_ref(
                32, 
                transaction_index, 
                begin_cell()
                    .store_slice(in_msg_body)
                    .store_dict(approves)
                    .store_uint(approve_points, 32)
                .end_cell()
            );

            save_data();
            return ();

        }

        ;; Index 2: ton routing transaction
        ;; transaction_info: int amount

        if (transaction_type == tt::withdraw_profit) {

            ;; Check transaction_info for initiating ton routing

            transaction_info_cs~load_uint(32); ;; int amount

            pending_transactions~udict_set_ref(
                32, 
                transaction_index, 
                begin_cell()
                    .store_slice(in_msg_body)
                    .store_dict(approves)
                    .store_uint(approve_points, 32)
                .end_cell()
            );

            save_data();
            return ();

        }

        ;; Index 3: Arbitrary transtransaction
        ;; transaction_info: slice destination, int amount, cell msg_body

        ;; !!!!!! rework

        if (transaction_type == tt::arbitrary_transaction) {

            ;; Check transaction_info for proposing arbitrary transtransaction

            transaction_info_cs~load_msg_addr(); ;; destination
            int amount = transaction_info_cs~load_uint(32); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body

            throw_if(666, amount > my_balance - total_profit_reserved);

            pending_transactions~udict_set_ref(
                32, 
                transaction_index, 
                begin_cell()
                    .store_slice(in_msg_body)
                    .store_dict(approves)
                    .store_uint(approve_points, 32)
                .end_cell()
            );

            save_data();
            return ();

        }

        ;; Index 4: start change settings
        ;; transaction_info: 

        if (transaction_type == tt::update_agreement_percent) {

            ;; Check transaction_info for proposing of changing of transaction approval percent

            agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; agreement_percent_numerator
            agreement_percent_denominator = transaction_info_cs~load_uint(32); ;; agreement_percent_denominator

            pending_transactions~udict_set_ref(
                32, 
                transaction_index, 
                begin_cell()
                    .store_slice(in_msg_body)
                    .store_dict(approves)
                    .store_uint(approve_points, 32)
                .end_cell()
            );

            save_data();
            return ();

        }

        if (transaction_type == tt::transfer_points) {

            ;; Add address with part of the poins of change address in case of all points transfer

            save_data();
            return ();
        }

    }

    if (op == op::change_my_address) {

        ~strdump("Start changing my address");

        int passcode = in_msg_body~load_uint(32);
        slice new_authorized_address = in_msg_body~load_msg_addr();
        (cell authorized_address_info, int flag) = authorized_addresses.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("Start authorized_address update");

            cell new_authorized_authorized_address_info = 
                begin_cell()
                    .store_slice(new_authorized_address)
                    .store_uint(approval_points, 32)
                    .store_uint(profit_points, 32)
                .end_cell();

            authorized_addresses~udict_set_get_ref(32, passcode, new_authorized_authorized_address_info);

        }

        save_data();
        return ();

    }

    if (op == op::quit_a_dao) {

        ~strdump("Start quiting A DAO");

        int passcode = in_msg_body~load_uint(32);
        (cell authorized_address_info, int flag) = authorized_addresses.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("Start authorized_address removal");

            (authorized_addresses, int flag) = authorized_addresses.udict_delete?(32, passcode);
            throw_unless(666, flag);

            ~strdump("Start points update");

            total_approval_points -= approval_points;
            total_profit_points -= profit_points;

            total_approval_points~dump();
            total_profit_points~dump();

        }

        save_data();
        return ();

    }

    if (op == op::accept_invitation_to_a_dao) {

        ~strdump("Start accepting invitation to A DAO");

        int passcode = in_msg_body~load_uint(32);
        (cell authorized_address_info, int flag) = pending_invitations.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();

        if (flag & equal_slices(sender_address, authorized_address)) {

            ~strdump("Sender authorized");

            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            ~strdump("End authorized_address adding");

            authorized_addresses~udict_set_ref(32, passcode, authorized_address_info);

            ~strdump("Start points update");

            total_approval_points += approval_points;
            total_profit_points += profit_points;

            total_approval_points~dump();
            total_profit_points~dump();

        }

        save_data();
        return ();

    }

    if (op == op::activate_a_dao) {

        ~strdump("Start A DAO Activation");

        throw_unless(333, equal_slices(sender_address, deployer_address));

        active? = true;
        agreement_percent_numerator = in_msg_body~load_uint(32);
        agreement_percent_denominator = in_msg_body~load_uint(32);
        profit_reserve_percent_numerator = in_msg_body~load_uint(32);
        profit_reserve_percent_denominator = in_msg_body~load_uint(32);
        profitable_addresses = in_msg_body~load_dict();
        pending_invitations = in_msg_body~load_dict();

        ~strdump("Start sending invites to A DAO");

        (int passcode, cell authorized_address_info, int flag) = pending_invitations.udict_get_min_ref?(32);

        while (flag) {

            slice authorized_address_info_cs = authorized_address_info.begin_parse();

            slice authorized_address = authorized_address_info_cs~load_msg_addr();
            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);

            cell msg = 
                begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(authorized_address)
                    .store_coins(30000000) ;; check on tests
                    .store_uint(1, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(op::invite_to_a_dao, 32)
                            .store_uint(passcode, 32)
                            .store_uint(approval_points, 32)
                            .store_uint(profit_points, 32)
                        .end_cell()
                    )
                .end_cell();

            send_raw_message(msg, 0);

            passcode += 1;

            (authorized_address_info, flag) = pending_invitations.udict_get_ref?(32, passcode);

            active? = true;
            
        }

        ~strdump("Terminate sending invites to A DAO");

        save_data();
        return ();

    }

    ;; Internal method of protocol

    if (op == op::process_deploy_message) {

        ~strdump("Start deploy message processing");

        throw_unless(666, equal_slices(sender_address, root_address));
        transaction_fee = in_msg_body~load_uint(32);
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;

        if (slice_bits(in_msg_body) > 0) { ;; If config added with deploy message

            agreement_percent_numerator = in_msg_body~load_uint(32);
            agreement_percent_denominator = in_msg_body~load_uint(32);
            pending_invitations = in_msg_body~load_dict();

            send_invites_to_a_dao(pending_invitations);

        }

        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0;

        active? = false;

        save_data();
        return();

    }

    throw(0xffff);

}

;; Custom get-methods

(int, slice, slice, int, int, int, int, int, cell, cell, cell, cell, int, int, int) get_a_dao_data() method_id {

    load_data();

    return (
        active?, ;; int1
        root_address, ;; slice
        deployer_address, ;; slice
        transaction_fee, ;; uint32
        agreement_percent_numerator, ;; uint32
        agreement_percent_denominator, ;; uint32
        profit_reserve_percent_numerator, ;; uint32
        profit_reserve_percent_denominator, ;; uint32
        profitable_addresses,
        pending_invitations, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int profit_points
        pending_transactions, ;; key: uint10 // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approve_points
        authorized_addresses, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int profit_points
        total_approval_points, ;; uint32
        total_profit_points, ;; uint32
        total_profit_reserved ;; uint32
    );

}