;; Imports

#include "stdlib.fc";

;; Operation Codes

const int op::process_deploy_message = 0;
const int op::master_log = 1;
const int op::activate_a_dao = 2;
const int op::propose_transaction = 3;
const int op::approve_transaction = 4;
const int op::collect_profit = 5;
const int op::accept_invitation_to_a_dao = 6;
const int op::buy_points = 7;
const int op::invite_to_a_dao = 8;
const int op::change_my_address = 9;
const int op::quit_a_dao = 10;

;; Transaction Types

const int tt::transaction_without_type = 0;
const int tt::invite_address = 1;
const int tt::delete_address = 2;
const int tt::withdraw_profit = 3;
const int tt::distribute_ton = 4;
const int tt::arbitrary_transaction = 5;
const int tt::update_agreement_percent = 6;
const int tt::transfer_points = 7;
const int tt::put_up_points_for_sale = 8;
const int tt::delete_pending_invitations = 9;
const int tt::delete_pending_transactions = 10;

;; Storage globals

    ;; Initial

    global int active?; ;; uint1
    global slice a_dao_master; ;; slice 257bits
    global slice deployer_address; ;; slice 257bits
    global int transaction_fee; ;; uint32

    ;; Active

    global int agreement_percent_numerator; ;; int32
    global int agreement_percent_denominator; ;; int32
    global int profit_reserve_percent_numerator; ;; int32
    global int profit_reserve_percent_denominator; ;; int32
    ;; udict profitable_addresses
        ;; Key: uint32
        ;; value (cell)
            ;; slice profitable_address
    global cell profitable_addresses;
    ;; udict pending_invitations
        ;; Key: uint32
        ;; value (cell)
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
    global cell pending_invitations; ;; on activation
    ;; udict pending_transactions
        ;; Key: uint32
        ;; value (cell)
            ;; int4 transaction_type
            ;; int32 deadline
            ;; cell transaction_info
            ;; dict approvals
            ;; int32 approval_points_recieved
    global cell pending_transactions;
    ;; udict authorized_addresses
        ;; Key: uint32
        ;; value (slice)
            ;; slice address
            ;; int32 approval_points
            ;; int32 profit_points
            ;; dict approved_invitations
            ;; dict approved_transactions
    global cell authorized_addresses;
    global int total_approval_points; ;; uint32
    global int total_profit_points; ;;uint32
    global int total_profit_reserved;

;; Storage functions

() save_data() impure inline {
    ~strdump("Start save_data()");
    set_data(
        begin_cell()
            .store_int(active?, 1)
            .store_slice(a_dao_master)
            .store_slice(deployer_address)
            .store_uint(transaction_fee, 32)
            .store_uint(agreement_percent_numerator, 32)
            .store_uint(agreement_percent_denominator, 32)
            .store_uint(profit_reserve_percent_numerator, 32)
            .store_uint(profit_reserve_percent_denominator, 32)
            .store_dict(profitable_addresses)
            .store_dict(pending_invitations)
            .store_dict(pending_transactions)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_profit_points, 32)
            .store_coins(total_profit_reserved)
        .end_cell()
    );
    ~strdump("End save_data()");
}

() load_data() impure inline { 
    ~strdump("Start load_data()");
    slice ds = get_data().begin_parse();
    active? = ds~load_int(1);
    a_dao_master = ds~load_msg_addr();
    deployer_address = ds~load_msg_addr();
    if (active? == false) {
        ~strdump("active? == false");
        transaction_fee = 0;
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;
        profit_reserve_percent_numerator = 0; 
        profit_reserve_percent_denominator = 0;
        profitable_addresses = new_dict();
        pending_invitations = new_dict();
        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0; 
        total_profit_reserved = 0;
    } else {
        ~strdump("active? == true");
        transaction_fee = ds~load_uint(32);
        agreement_percent_numerator = ds~load_uint(32);
        agreement_percent_denominator = ds~load_uint(32);
        profit_reserve_percent_numerator = ds~load_uint(32); 
        profit_reserve_percent_denominator = ds~load_uint(32);
        profitable_addresses = ds~load_dict();
        pending_invitations = ds~load_dict();
        pending_transactions = ds~load_dict();
        authorized_addresses = ds~load_dict();
        total_approval_points = ds~load_uint(32);
        total_profit_points = ds~load_uint(32); 
        total_profit_reserved = ds~load_coins();
        ds.end_parse();
    }
    ~strdump("End load_data()");
}

() just_notify_master(int op, int transaction_type) impure inline {
    cell msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(a_dao_master)
        .store_coins(transaction_fee)
        .store_uint(1, 107)
        .store_ref(
            begin_cell()
                .store_uint(op, 32)
                .store_uint(transaction_type, 32)
            .end_cell()
        )
    .end_cell();
    send_raw_message(msg, 1);
}

() send_invites_to_a_dao(cell pending_invitations) impure inline {
    ~strdump("Start sending invites to A DAO");
    (int passcode, cell authorized_address_info, int success?) = pending_invitations.udict_get_min_ref?(32);
    while (success?) {
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        int approval_points = authorized_address_info_cs~load_uint(32);
        int profit_points = authorized_address_info_cs~load_uint(32);
        cell msg = 
            begin_cell()
                .store_uint(0x18, 6)
                .store_slice(authorized_address)
                .store_coins(30000000) ;; check on tests
                .store_uint(1, 107)
                .store_ref(
                    begin_cell()
                        .store_uint(op::invite_to_a_dao, 32)
                        .store_uint(passcode, 32)
                        .store_uint(approval_points, 32)
                        .store_uint(profit_points, 32)
                    .end_cell()
                )
            .end_cell();
        send_raw_message(msg, 0);
        passcode += 1;
        (authorized_address_info, success?) = pending_invitations.udict_get_ref?(32, passcode);
        active? = true;
    }
    ~strdump("Terminate sending invites to A DAO");
}

() clear_pending_transactions_queue(cell pending_transactions) inline {
    (int key, slice transaction_info, int success?) = pending_transactions.udict_get_min?(256);
    while (success?) {
        (key, transaction_info, success?) = pending_transactions.udict_get_next?(256, key);
        transaction_info~skip_bits(8); ;; skip transaction_type
        transaction_info~load_uint(32); ;; deadline
    }
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    slice cs = in_msg_full.begin_parse();
    int success?s = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    if (success?s & 1) { return (); }
    int op = in_msg_body~load_uint(32);
    load_data();
    if (op == op::approve_transaction) {
        ~strdump("Start transaction approval");
        int transaction_index = in_msg_body~load_uint(32);
        ~strdump("Start sender authorization");
        int sender_address_sha256 = slice_hash(sender_address);
        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, sender_address_sha256);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        throw_unless(222, success? & equal_slices(sender_address, authorized_address));
        ~strdump("Start points parsing");
        int approval_points = authorized_address_info_cs~load_uint(32);
        int profit_points = authorized_address_info_cs~load_uint(32);
        ~strdump("Get transaction by transaction_index");
        transaction_index~dump();
        (cell transaction, int success?) = pending_transactions.udict_get_ref?(32, transaction_index);
        throw_unless(200, success?);
        ~strdump("Parse transaction");
        slice transaction_cs = transaction.begin_parse();
        int transaction_type = transaction_cs~load_uint(32); ;; transaction_type
        int deadline = transaction_cs~load_uint(32); ;; deadline
        cell transaction_info = transaction_cs~load_ref(); ;; transaction_info
        cell approvals = transaction_cs~load_dict(); ;; approvals
        int approval_points_recieved = transaction_cs~load_uint(32); ;; approval_points_recieved
        ;; Check if not second approve
        ~strdump("Add approve to approvals dictionary");
        int sender_address_sha256 = slice_hash(sender_address);
        int success? = approvals~udict_add?(256, sender_address_sha256, transaction_cs);
        ~strdump("Count approvals");
        int approvals_for_approval = total_approval_points * agreement_percent_numerator / agreement_percent_denominator;
        approval_points_recieved = approval_points_recieved + approval_points;
        ~strdump("Delete old transaction state from pending_transactions");
        (pending_transactions, int success?) = pending_transactions.udict_delete?(32, transaction_index);
        throw_unless(666, success?);
        ~strdump("Start check if sufficient approvals to start actions");
        if (approval_points_recieved > approvals_for_approval) {
            slice transaction_info_cs = transaction_info.begin_parse();
            if (transaction_type == tt::invite_address) {
                ~strdump("Start Transaction Approval: Invite Address");
                (int last_passcode, _, _) = pending_invitations.udict_get_max_ref?(32);
                int passcode = last_passcode + 1;
                slice authorized_address = transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                int profit_points = transaction_info_cs~load_uint(32); ;; int profit_points
                ~strdump("Add address to pending invitations");
                pending_invitations~udict_set_ref(32, passcode, transaction_info);
                ~strdump("Send invitation to authorized_address");
                cell msg = 
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(authorized_address)
                        .store_coins(30000000) ;; check on tests
                        .store_uint(1, 107)
                        .store_ref(
                            begin_cell()
                                .store_uint(op::invite_to_a_dao, 32)
                                .store_uint(passcode, 32)
                                .store_uint(approval_points, 32)
                                .store_uint(profit_points, 32)
                            .end_cell()
                        )
                    .end_cell();
                send_raw_message(msg, 0);
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::delete_address) {
                ~strdump("Start Transaction Approval: Delete Address");
                slice address_to_delete = transaction_info_cs~load_msg_addr();
                ~strdump("Decrease total points");
                int address_to_delete_sha256 = slice_hash(address_to_delete);
                (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, address_to_delete_sha256);
                authorized_address_info_cs~load_msg_addr(); ;; slice authorized_address
                int approval_points = authorized_address_info_cs~load_uint(32);
                int profit_points = authorized_address_info_cs~load_uint(32);
                total_approval_points = total_approval_points - approval_points;
                total_profit_points = total_profit_points - profit_points;
                ~strdump("Delete address from dict");
                (authorized_addresses, int success?) = authorized_addresses.udict_delete?(256, address_to_delete_sha256);
                save_data();
                total_approval_points~dump();
                total_profit_points~dump();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::withdraw_profit) {
                ~strdump("Start Transaction Approval: Withdraw Profit");
                int profitable_address_passcode = transaction_info_cs~load_uint(32);
                (cell profitable_address_info, int success?) = profitable_addresses.udict_get_ref?(32, profitable_address_passcode);
                throw_unless(222, success?);
                slice profitable_address_info_cs = profitable_address_info.begin_parse();
                slice profitable_address = profitable_address_info_cs~load_msg_addr();
                var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(profitable_address)
                    .store_coins(330000000)
                    .store_uint(1, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(48, 32) ;; int32 op::withdraw_funds
                        .end_cell()
                    )
                .end_cell();
                send_raw_message(msg, 0);
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::distribute_ton) {
                ~strdump("Start Transaction Approval: Distribute Ton");
                int ton_to_distribute = transaction_info_cs~load_coins(); ;; int amount
                ~strdump("Start sending TON to authorized addresses");
                (int key, slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get_min?(256);
                ~strdump("Start sending TON to authorized addresses");
                while (success?) {
                    ~strdump("In while cycle");
                    slice address = authorized_address_info_cs~load_msg_addr();
                    int approval_points = authorized_address_info_cs~load_uint(32);
                    int profit_points = authorized_address_info_cs~load_uint(32);
                    int ton_amount_to_address = ton_to_distribute / total_profit_points * profit_points;
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(ton_amount_to_address)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);
                    (key, authorized_address_info_cs, success?) = authorized_addresses.udict_get_next?(256, key);

                }
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::arbitrary_transaction) {
                ~strdump("Start Transaction Approval: Arbitrary Transaction");
                slice recipient = transaction_info_cs~load_msg_addr(); ;; recipient
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body
                throw_if(666, amount > my_balance - total_profit_reserved);
                var msg = 
                    begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(recipient)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();
                send_raw_message(msg, 0);
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::update_agreement_percent) {
                ~strdump("Start Transaction Approval: Update Agreement Percent");
                agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; parse and save new settings
                agreement_percent_denominator = transaction_info_cs~load_uint(32);
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::transfer_points) {
                ~strdump("Start Transaction Approval: Transfer Points");
                ~strdump("Parse transaction info");
                slice points_sender = transaction_info_cs~load_msg_addr();
                slice points_recipient = transaction_info_cs~load_msg_addr();
                int approval_points_in_transfer = transaction_info_cs~load_uint(32);
                int profit_points_in_transfer = transaction_info_cs~load_uint(32);
                ~strdump("Get points sender info");
                int points_sender_sha256 = slice_hash(points_sender);
                (slice points_sender_info_cs, int success?) = authorized_addresses.udict_get?(256, points_sender_sha256);
                throw_unless(666, success?);
                int sender_approval_points = points_sender_info_cs~load_uint(32);
                int sender_profit_points = points_sender_info_cs~load_uint(32);
                cell sender_approved_invitations = points_sender_info_cs~load_dict();
                cell sender_approved_transactions = points_sender_info_cs~load_dict();
                ~strdump("Check recipient in authorized_addresses");
                int points_recipient_sha256 = slice_hash(points_recipient);
                (slice points_recipient_info_cs, int success?) = authorized_addresses.udict_get?(256, points_recipient_sha256);
                if (success?) {
                    ~strdump("recipient address present in authorized_addresses");
                    int old_recipient_approval_points = points_recipient_info_cs~load_uint(32);
                    int old_recipient_profit_points = points_recipient_info_cs~load_uint(32);
                    cell old_recipient_approved_invitations = points_recipient_info_cs~load_dict();
                    cell old_recipient_approved_transactions = points_recipient_info_cs~load_dict();
                    ~strdump("Count new recipient approval & profit points");
                    int recipient_approval_points = old_recipient_approval_points + approval_points_in_transfer;
                    int recipient_profit_points = old_recipient_profit_points + profit_points_in_transfer;
                    ~strdump("Start recipient & sender invitations approvals harmonization");
                    (int approved_address_sha256, slice sender_approved_invitation_cs, int success?) = sender_approved_invitations.udict_get_min?(32);
                    cell new_recipient_approved_invitations = new_dict();
                    cell new_sender_approved_invitations = new_dict();
                    while (success?) {
                        (slice recipient_approved_invitation_cs, int success?) = old_recipient_approved_invitations.udict_get?(32, approved_address_sha256);
                        if (success?) {
                            ~strdump("Update new_recipient_approved_invitations");
                            int old_recipient_points_on_invitation = recipient_approved_invitation_cs~load_uint(32);
                            int recipient_points_on_invitation = old_recipient_points_on_invitation + approval_points_in_transfer;
                            new_recipient_approved_invitations~udict_set(32, approved_address_sha256,
                                begin_cell()
                                    .store_uint(recipient_points_on_invitation, 32)
                                .end_cell().begin_parse()
                            );
                            ~strdump("Update new_sender_approved_invitations");
                            int old_sender_points_on_invitation = sender_approved_invitation_cs~load_uint(32);
                            int sender_points_on_invitation = old_sender_points_on_invitation - approval_points_in_transfer;
                            new_sender_approved_invitations~udict_set(32, approved_address_sha256,
                                begin_cell()
                                    .store_uint(sender_points_on_invitation, 32)
                                .end_cell().begin_parse()
                            );
                        } else {
                            new_recipient_approved_invitations~udict_set(32, approved_address_sha256, recipient_approved_invitation_cs);
                        }
                        (int approved_address_sha256, slice sender_approved_invitation_cs, int success?) = sender_approved_invitations.udict_get_next?(256, approved_address_sha256);
                    }
                    ~strdump("Start recipient & sender transactions approvals harmonization");
                    cell new_recipient_approved_transactions = new_dict();
                    cell new_sender_approved_transactions = new_dict();
                    (int approved_address_sha256, slice sender_approved_invitation_cs, int success?) = sender_approved_transactions.udict_get_min?(32);
                    while (success?) {
                        (slice recipient_approved_invitation_cs, int success?) = old_recipient_approved_transactions.udict_get?(32, approved_address_sha256);
                        if (success?) {
                            ~strdump("Update new_recipient_approved_transactions");
                            int old_recipient_points_on_invitation = recipient_approved_invitation_cs~load_uint(32);
                            int recipient_points_on_invitation = old_recipient_points_on_invitation + approval_points_in_transfer;
                            new_recipient_approved_transactions~udict_set(32, approved_address_sha256,
                                begin_cell()
                                    .store_uint(recipient_points_on_invitation, 32)
                                .end_cell().begin_parse()
                            );
                            ~strdump("Update new_sender_approved_transactions");
                            int old_sender_points_on_invitation = sender_approved_invitation_cs~load_uint(32);
                            int sender_points_on_invitation = old_sender_points_on_invitation - approval_points_in_transfer;
                            new_sender_approved_transactions~udict_set(32, approved_address_sha256,
                                begin_cell()
                                    .store_uint(sender_points_on_invitation, 32)
                                .end_cell().begin_parse()
                            );
                        } else {
                            new_recipient_approved_transactions~udict_set(32, approved_address_sha256, recipient_approved_invitation_cs);
                        }
                        (int approved_address_sha256, slice sender_approved_invitation_cs, int success?) = sender_approved_transactions.udict_get_next?(256, approved_address_sha256);
                    }
                } else {
                    ~strdump("recipient address is not present in authorized_addresses"); ;; add from accept invitations

                    ~strdump("Create sender_approved_transactions ");

                }
                ~strdump("Count new approval & profit points");
                int new_sender_approval_points = sender_approval_points - approval_points_in_transfer;
                int new_sender_profit_points = sender_profit_points - profit_points_in_transfer;
                ~strdump("Delete current points sender state from authorized_addresses");
                int points_sender_sha256 = slice_hash(points_sender);
                (cell authorized_addresses, int success?) = authorized_addresses.udict_delete?(256, points_sender_sha256);
                throw_unless(666, success?);
                ~strdump("Add current points sender state");
                if ((new_sender_approval_points != 0) & (new_sender_profit_points != 0)) {
                    authorized_addresses~udict_set(256, slice_hash(points_sender), 
                        begin_cell()
                            .store_slice(points_sender)
                            .store_uint(new_sender_approval_points, 32)
                            .store_uint(new_sender_profit_points, 32)
                        .end_cell().begin_parse()
                    );
                }
                (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, slice_hash(points_recipient));
                ;; Transfer active approvals & devide approval_points
                ;; (slice authorized_address_info_cs, success?)
                ~strdump("Delete address from authorized_addresses if all points transfered");
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::put_up_points_for_sale) {

            }
            if (transaction_type == tt::delete_pending_invitations) {
                ~strdump("Start Transaction Approval: Delete Pending Invitations");
                cell pending_invitations_for_removal = transaction_info_cs~load_dict();
                ~strdump("Parse pending_invitations_for_removal dictionary");
                (int key, slice pending_invitation_for_removal, int success?) = pending_invitations_for_removal.udict_get_min?(32);
                while (success?) {
                    ~strdump("Remove pending_invitation_for_removal");
                    (pending_invitations, int flag) = pending_invitations.udict_delete?(32, key);
                    (key, slice pending_invitation_for_removal, int success?) = pending_invitations_for_removal.udict_get_next?(32, key);
                }
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
            if (transaction_type == tt::delete_pending_transactions) {
                ~strdump("Start Transaction Approval: Delete Pending Transactions");
                cell pending_transactions_for_removal = transaction_info_cs~load_dict();
                ~strdump("Parse pending_transactions_for_removal dictionary");
                (int key, slice pending_transaction_for_removal, int success?) = pending_transactions_for_removal.udict_get_min?(32);
                while (success?) {
                    ~strdump("Remove pending_transaction_for_removal");
                    (pending_transactions, int flag) = pending_transactions.udict_delete?(32, key);
                    (key, slice pending_transaction_for_removal, success?) = pending_transactions_for_removal.udict_get_next?(32, key);
                    success?~dump();
                }
                save_data();
                just_notify_master(op, transaction_type);
                return();
            }
        } else {
            ~strdump("Save new transaction state if not sufficient points for actions");
            cell new_transaction_state = begin_cell()
                .store_uint(transaction_type, 32)
                .store_uint(deadline, 32)
                .store_ref(transaction_info)
                .store_dict(approvals)
                .store_uint(approval_points_recieved, 32)
            .end_cell();
            pending_transactions~udict_set_ref(32, transaction_index, new_transaction_state);
        }
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::propose_transaction) {
        ~strdump("Start transaction proposal");
        ~strdump("Start proposal initiator authorization");
        int sender_address_sha256 = slice_hash(sender_address);
        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, sender_address_sha256);
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        throw_unless(222, success? & equal_slices(sender_address, authorized_address));
        ~strdump("Start proposal parsing");
        int transaction_type = in_msg_body.preload_uint(32);
        int deadline = in_msg_body.preload_uint(32);
        cell transaction_info = in_msg_body.preload_ref();
        ~strdump("Get max pending_transactions index");
        (int max_transaction_index, _, int success?) = pending_transactions.udict_get_max?(32);
        if (~ success?) {
            max_transaction_index = -1;
        }
        ~strdump("Convert transaction_info to slice");
        slice transaction_info_cs = transaction_info.begin_parse();
        ~strdump("Set zero approvals");
        cell approvals = new_dict();
        int approval_points_recieved = 0;
        if (transaction_type == tt::invite_address) {
            ~strdump("Start Proposal: Invite Address");
            slice address_to_invite = transaction_info_cs~load_msg_addr();
            int approval_points = transaction_info_cs~load_uint(32);
            int profit_points = transaction_info_cs~load_uint(32);
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(
                        begin_cell()
                            .store_slice(address_to_invite)
                            .store_uint(approval_points, 32)
                            .store_uint(profit_points, 32)
                            .store_dict(new_dict()) ;; dict active_invitations_approvals
                            .store_dict(new_dict()) ;; dict active_transaction_approvals
                        .end_cell()
                    )
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::delete_address) {
            ~strdump("Start Transaction Proposal: Delete Address");
            transaction_info_cs~load_msg_addr(); ;; slice address_to_delete
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::withdraw_profit) {
            ~strdump("Start Transaction Proposal: Withdraw Profit");
            transaction_info_cs~load_uint(32); ;; int profitable_address_passcode
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::distribute_ton) {
            ~strdump("Start Transaction Proposal: Distribute Ton");
            transaction_info_cs~load_coins(); ;; int distribution_amount
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::arbitrary_transaction) {
            ~strdump("Start Transaction Proposal: Arbitrary Transaction");
            transaction_info_cs~load_msg_addr(); ;; recipient
            int amount = transaction_info_cs~load_coins(); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body
            ~strdump("Check the integrity of reserves");
            throw_if(666, amount > my_balance - total_profit_reserved);
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return(); 
        }
        if (transaction_type == tt::update_agreement_percent) {
            ~strdump("Start Transaction Proposal: Update Agreement Percent");
            transaction_info_cs~load_uint(32); ;; int agreement_percent_numerator
            transaction_info_cs~load_uint(32); ;; int agreement_percent_denominator
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::transfer_points) {
            ~strdump("Start Transaction Proposal: Transfer Points");
            slice recipient = transaction_info_cs~load_msg_addr();
            int approval_points_in_transfer = transaction_info_cs~load_uint(32);
            int profit_points_in_transfer = transaction_info_cs~load_uint(32);
            ~strdump("Check points availability");
            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);
            throw_if(666, approval_points_in_transfer > approval_points);
            throw_if(777, profit_points_in_transfer > profit_points);
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(
                        begin_cell()
                            .store_slice(sender_address)
                            .store_slice(recipient)
                            .store_uint(approval_points_in_transfer, 32)
                            .store_uint(profit_points_in_transfer, 32)
                        .end_cell()
                    )
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::put_up_points_for_sale) {

        }
        if (transaction_type == tt::delete_pending_invitations) {
            ~strdump("Start Transaction Proposal: Delete Pending Invitations");
            transaction_info_cs~load_dict(); ;; dict pending_invitations_for_removal
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
        if (transaction_type == tt::delete_pending_transactions) {
            ~strdump("Start Transaction Proposal: Delete Pending Transactions");
            transaction_info_cs~load_dict(); ;; dict pending_transactions_for_removal
            ~strdump("Add transaction to pending_transactions");
            pending_transactions~udict_set_ref(
                32, 
                max_transaction_index + 1, 
                begin_cell()
                    .store_uint(transaction_type, 32)
                    .store_uint(deadline, 32)
                    .store_ref(transaction_info)
                    .store_dict(approvals)
                    .store_uint(approval_points_recieved, 32)
                .end_cell()
            );
            save_data();
            just_notify_master(op, transaction_type);
            return();
        }
    }
    if (op == op::collect_profit) {
        ~strdump("Start profit collecting");
        total_profit_reserved~dump();
        total_profit_reserved = msg_value * profit_reserve_percent_numerator / profit_reserve_percent_denominator + total_profit_reserved;
        total_profit_reserved~dump();
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::change_my_address) {
        ~strdump("Start changing my address");
        slice new_authorized_address = in_msg_body~load_msg_addr();
        ~strdump("Start udict_get?");
        int sender_address_sha256 = slice_hash(sender_address);
        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, sender_address_sha256);
        ~strdump("End udict_get?");
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        if (success? & equal_slices(sender_address, authorized_address)) {
            ~strdump("Sender authorized");
            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);
            ~strdump("Start authorized_address update");
            slice new_authorized_authorized_address_info = 
                begin_cell()
                    .store_slice(new_authorized_address)
                    .store_uint(approval_points, 32)
                    .store_uint(profit_points, 32)
                .end_cell().begin_parse();
            authorized_addresses~udict_set(256, slice_hash(new_authorized_address), new_authorized_authorized_address_info);

        }
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::quit_a_dao) {
        ~strdump("Start quiting A DAO");
        int sender_address_sha256 = slice_hash(sender_address);
        (slice authorized_address_info_cs, int success?) = authorized_addresses.udict_get?(256, sender_address_sha256);
        ~strdump("End udict_get?");
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        if (success? & equal_slices(sender_address, authorized_address)) {
            ~strdump("Sender authorized");
            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);
            ~strdump("Start authorized_address removal");
            int sender_address_sha256 = slice_hash(sender_address);
            (authorized_addresses, int success?) = authorized_addresses.udict_delete?(256, sender_address_sha256);
            throw_unless(666, success?);
            ~strdump("Start points update");
            total_approval_points -= approval_points;
            total_profit_points -= profit_points;
        }
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::accept_invitation_to_a_dao) {
        ~strdump("Start accepting invitation to A DAO");
        int passcode = in_msg_body~load_uint(32);
        (cell authorized_address_info, int success?) = pending_invitations.udict_get_ref?(32, passcode);
        slice authorized_address_info_cs = authorized_address_info.begin_parse();
        slice authorized_address = authorized_address_info_cs~load_msg_addr();
        if (success? & equal_slices(sender_address, authorized_address)) {
            ~strdump("Sender authorized");
            int approval_points = authorized_address_info_cs~load_uint(32);
            int profit_points = authorized_address_info_cs~load_uint(32);
            ~strdump("End authorized_address adding");
            int sender_address_sha256 = slice_hash(sender_address);
            authorized_addresses~udict_set(256, sender_address_sha256, authorized_address_info.begin_parse());
            ~strdump("Start points update");
            total_approval_points += approval_points;
            total_profit_points += profit_points;
        }
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::activate_a_dao) {
        ~strdump("Start A DAO Activation");
        throw_unless(333, equal_slices(sender_address, deployer_address));
        active? = true;
        agreement_percent_numerator = in_msg_body~load_uint(32);
        agreement_percent_denominator = in_msg_body~load_uint(32);
        profit_reserve_percent_numerator = in_msg_body~load_uint(32);
        profit_reserve_percent_denominator = in_msg_body~load_uint(32);
        profitable_addresses = in_msg_body~load_dict();
        pending_invitations = in_msg_body~load_dict();
        send_invites_to_a_dao(pending_invitations);
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    if (op == op::process_deploy_message) {
        ~strdump("Start deploy message processing");
        throw_unless(666, equal_slices(sender_address, a_dao_master));
        transaction_fee = in_msg_body~load_uint(32);
        agreement_percent_numerator = 0;
        agreement_percent_denominator = 0;
        if (slice_bits(in_msg_body) > 0) { ;; If config added with deploy message
            agreement_percent_numerator = in_msg_body~load_uint(32);
            agreement_percent_denominator = in_msg_body~load_uint(32);
            pending_invitations = in_msg_body~load_dict();
            send_invites_to_a_dao(pending_invitations);
        }
        pending_transactions = new_dict();
        authorized_addresses = new_dict();
        total_approval_points = 0;
        total_profit_points = 0;
        active? = false;
        save_data();
        just_notify_master(op, tt::transaction_without_type);
        return();
    }
    throw(0xffff);
}

;; Custom get-methods

(int, slice, slice, int, int, int, int, int, cell, cell, cell, cell, int, int, int) get_a_dao_data() method_id {
    load_data();
    return (
        active?, ;; int1
        a_dao_master, ;; slice
        deployer_address, ;; slice
        transaction_fee, ;; uint32
        agreement_percent_numerator, ;; uint32
        agreement_percent_denominator, ;; uint32
        profit_reserve_percent_numerator, ;; uint32
        profit_reserve_percent_denominator, ;; uint32
        profitable_addresses,
        pending_invitations, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int profit_points
        pending_transactions, ;; key: uint10 // value (cell): int transaction_type, int deadline, cell transaction_info, cell approvals, int approval_points_recieved
        authorized_addresses, ;; key: int address_sha256_hash // value (slice): slice address,  int approval_points, int profit_points
        total_approval_points, ;; uint32
        total_profit_points, ;; uint32
        total_profit_reserved ;; uint32
    );
}