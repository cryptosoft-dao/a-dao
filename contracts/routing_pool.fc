#include "imports/stdlib.fc";

;; Operation codes

const int op::activate_routing_pool = 1;
const int op::propose_transaction = 2;
const int op::approve_transaction = 3;
const int op::quit_routing_pool = 4;
const int op::create_routing_pool = 5;
const int op::deactivate_routing_pool = 6;

;; Transaction types

const int tt::invite_address = 0;
const int tt::exclude_address = 1;
const int tt::distribute_ton = 2;
const int tt::arbitrary_transaction = 3;
const int tt::change_max_authorized_addresses = 4;
const int tt::transaction_approval_percent = 4;

;; Global variables

global slice deployer_address;
global slice root_address;

global int blockchain_fee;
global int transactions_fee;
global int creation_fee;
global int referal_creation_discount_denominator;

global int max_authorized_addresses;
global int transaction_approval_percent;
global int max_pending_transactions;
global int max_pending_invitations;

global cell authorized_addresses; ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
global int total_approval_points;
global int total_distribution_points;
global cell pending_transactions; ;; key: int address_sha256_hash // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approve_points
global cell pending_invitations; ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points

() save_data() impure inline {

    set_data(
        begin_cell()
            .store_slice(deployer_address)
            .store_uint(max_authorized_addresses, 8)
            .store_uint(transaction_approval_percent, 8)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_distribution_points, 32)
            .store_dict(pending_transactions)
            .store_dict(pending_invitations)
        .end_cell()
    );
}

() load_data() impure inline { 

    slice ds = get_data().begin_parse();
    deployer_address = ds~load_msg_addr()
    max_authorized_addresses = ds~load_uint(8);
    transaction_approval_percent = ds~
    authorized_addresses = ds~load_dict();
    total_approval_points = ds~load_uint(32)
    total_distribution_points = ds~load_uint(32)
    pending_transactions = ds~load_dict();
    pending_invitations = ds~load_dict();
    ds.end_parse();

}

() clear_pending_transactions_queue() inline {

    (int key, slice value, int success?) = pending_transactions.udict_get_min?(256);

    while (success?) {
        (key, value, success?) = pending_transactions.udict_get_next?(256, key);

        value~skip_bits(8); ;; skip transaction_type
        value~load_uint(32); ;; deadline
    }
}

() add_cached_transaction() inline {

    (int key, slice value, int success?) = udict_get_max?(pending_transactions, 64);

    if (key = 255) {
        clear_pending_transactions_queue(pending_transactions);
    }

    if (success?) {
        pending_transactions~udict_add?(64, key + 1, cached_transaction);
    }
}

(int) check_authority(slice sender_address, int address_index) inline {

    (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);

    if (equal_slices(sender_address, address_info~load_msg_addr())) {
        return true;
    } else {
        return false;
    }
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::approve_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        

        int address_index = in_msg_body~load_uint(8);
        int transaction_index = in_msg_body~load_uint(8);

        ;; get transaction by transaction_index

        (slice transaction, int found?) = pending_transactions.udict_get?(8, transaction_index);
        throw_unless(200, found?);

        ;; Parse transaction

        int transaction_type = transaction~load_uint(4); ;; transaction_type
        int deadline = transaction~load_uint(32); ;; deadline
        cell transaction_info = transaction~load_ref(); ;; transaction_info
        cell approves = transaction~load_ref(); ;; approves
        int approve_points = transaction~load_uint(32); ;; approve_points

        ;; add approve

        int success? = approves~udict_add?(8, address_index, transaction);

        ;; get info about address from authorized_addresses

        (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);
        throw_unless(111, success?); ;; throw if there is not such a address

        slice address = address_info~load_msg_addr();
        int approval_points = address_info~load_uint(32);
        int distribution_points = address_info~load_uint(32);

        ;; Calculate new total transaction

        int new_approve_points = approve_points + approval_points;

        ;; Parse settings

        slice settings_cs = settings.begin_parse();
        int max_authorized_addresses = settings_cs~load_uint(8); ;; skip 
        int agreement_percent = settings_cs~load_uint(8);

        int approves_for_approval = agreement_percent / total_credits * 100;

        ;; Do pending_transactions in case of approval, otherwise save approve

        if (new_approve_points > approves_for_approval) {

            slice transaction_info_cs = transaction_info.begin_parse();

            ;; Do pending_transactions

            if (transaction_type == tt::add_address) {

                (int last_address_index, _, _) = pending_transactions.udict_get_max?(8);
                int new_address_index = last_address_index + 1;

                transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                transaction_info_cs~load_uint(32); ;; int distribution_points

                ;; Add new address to dict

                if (new_address_index < max_authorized_addresses) {
                    authorized_addresses~udict_add?(8, new_address_index, transaction_info_cs);
                }

                ;; Increase total approves

                total_credits += approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::delete_address) {

                int address_to_delete_index = transaction_info_cs~load_uint(8);

                ;; Delete address from dict

                authorized_addresses.udict_delete?(8, address_to_delete_index);

                ;; Decrease total approves

                total_credits -= approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::withdraw_ton) {

                int ton_to_route = transaction_info_cs~load_uint(32); ;; int amount

                ;; Route ton

                (int key, slice value, int success?) = authorized_addresses.udict_get_min?(64);

                while (success?) {

                    slice address = address_info~load_msg_addr();
                    int approval_points = address_info~load_uint(32);
                    int distribution_points = address_info~load_uint(32);

                    int address_ton = ton_to_route / total_credits * approval_points;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(address_ton)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);
                }

                save_data();
                return ();

            }

            if (transaction_type == tt::arbitrary_transaction) {

                slice destination = transaction_info_cs~load_msg_addr(); ;; destination
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body

                ;; Arbitrary transtransaction

                var msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(destination)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();
                send_raw_message(msg, 0);

                save_data();
                return ();

            }

            if (transaction_type == tt::change_settings) {

                settings = transaction_info_cs~load_ref(); ;; parse and save new settings

                save_data();
                return ();

            }

        } else {

            approves~udict_add?(8, transaction_index, transaction);
        }

    }

    ;; start transaction msg: int address_index, int transaction_index, cell transaction_cell

    if (op == op::propose_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        int transaction_index = in_msg_body~load_uint(8);
        cell transaction_cell = in_msg_body~load_ref();

        slice transaction_cell_cs = transaction_cell.begin_parse();

        ;; Check transaction info

        int transaction_type = transaction_cell_cs.preload_uint(4);
        int deadline = transaction_cell_cs.preload_uint(32);
        cell transaction_info = transaction_cell_cs.preload_ref();
        cell approves = transaction_cell_cs.preload_ref();
        int approve_points = transaction_cell_cs.preload_uint(32);

        slice transaction_info_cs = transaction_info.begin_parse();

        ;; Index 0: Add address
        ;; transaction_info: slice address_to_add_addr

        if (transaction_type == tt::add_address) {

            ;; Check transaction_info for initiating adding address

            transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int distribution_points

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 1: Eliminate address
        ;; transaction_info: slice address_to_eliminate_addr

        if (transaction_type == tt::delete_address) {

            ;; Check transaction_info for initiating termination of authority

            transaction_info_cs~load_msg_addr(); ;; slice address_to_eliminate_addr

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 2: ton routing transaction
        ;; transaction_info: int amount

        if (transaction_type == tt::withdraw_ton) {

            ;; Check transaction_info for initiating ton routing

            transaction_info_cs~load_uint(32); ;; int amount

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 3: Arbitrary transtransaction
        ;; transaction_info: slice destination, int amount, cell msg_body

        if (transaction_type == tt::random_transaction) {

            ;; Check transaction_info for initiating arbitrary transtransaction

            transaction_info_cs~load_msg_addr(); ;; destination
            transaction_info_cs~load_uint(32); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 4: start change settings
        ;; transaction_info: 

        if (transaction_type == tt::change_settings) {

            ;; Check transaction_info for changing settings

            transaction_info_cs~load_uint(8); ;; max_authorized_addresses
            transaction_info_cs~load_uint(8); ;; agreement_percent

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        if (transaction_type == tt::deinitialize_contract) {

            save_data();
            return ();

        }

    }

    if (op == op::accept_invitation_to_routing_pool) {

        

    }

    if (op == op::quit_contract) {

        ;; Check if sender is an authorized routing pool wallet

        

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        authorized_addresses.udict_delete?(8, address_index);

        save_data();
        return ();

    }

    if (op == op::activate_routing_pool) {

        throw_unless(333, equal_slices?(sender_address, routing_pool_of_routing_pools_addr))
        throw_unless(666, get_data().begin_parse().slice_empty());

        max_authorized_addresses = in_msg_body~load_uint(8);
        transaction_approval_percent = in_msg_body~load_uint(8);

        approval_points = in_msg_body~load_uint(8);
        distribution_points = in_msg_body~load_uint(8);

        max_authorized_addresses = in_msg_body~load_uint(8);
        agreement_percent = in_msg_body~load_uint(8);
        authorized_addresses = new_dict();

        total_approval_points = 0;
        total_distribution_points = 0;
        pending_transactions = new_dict();
        pending_invitations = 

        ;; Send invites to routing pool

        save_data();
        return ();

    }

    if (op::deactivate_routing_pool) {



    }

    throw(0xffff);

}

() get_routing_pool_data() {

    load_data();

    return (
        deployer_address,
        routing_pool_index,
        max_authorized_addresses,
        transaction_approval_percent,
        authorized_addresses, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
        total_approval_points,
        total_distribution_points,
        pending_transactions, ;; key: int address_sha256_hash // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approve_points
        pending_invitations, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
    );

}