#include "imports/stdlib.fc";

;; Operation codes

const int op::process_deploy_message = 0;
const int op::activate_routing_pool = 1;
const int op::propose_transaction = 2;
const int op::approve_transaction = 3;
const int op::accept_invitation_to_routing_pool = 5;
const int op::quit_routing_pool = 6;

;; Transaction types

const int tt::invite_address = 0;
const int tt::delete_address = 1;
const int tt::distribute_ton = 2;
const int tt::arbitrary_transaction = 3;
const int tt::update_agreement_percent = 4;

;; Storage globals

global int active?;
global slice root_address; ;; slice 257bits ;; initial state
global int deployer_address_sha256; ;; slice 257bits ;; initial state
global int transaction_fee; ;; uint32
global int agreement_percent_numerator; ;; int32 ;; on activation
global int agreement_percent_denominator; ;; int32 ;; on activation
;; dict pending_invitations
    ;; Key: uint256 address_sha256_hash
    ;; Value
        ;; slice address
        ;; int32 approval_points
        ;; int32 distribution_points
global cell pending_invitations; ;; on activation
;; dict pending_transactions
    ;; Key: uint256 address_sha256_hash
    ;; Value (cell)
        ;; int4 transaction_type
        ;; int32 deadline
        ;; cell transaction_info
        ;; cell approves
        ;; int32 approve_points
global cell pending_transactions;
;; dict authorized_addresses
    ;; Key: uint256 address_sha256_hash
    ;; Value (cell)
        ;; slice address
        ;; int32 approval_points
        ;; int32 distribution_points
global cell authorized_addresses;
global int total_approval_points; ;; uint32
global int total_distribution_points; ;;uint32

;; Storage functions

() load_data() impure inline { 

    slice ds = get_data().begin_parse();
        root_address = ds~load_msg_addr();
        deployer_address_sha256 = ds~load_uint(256);
        transaction_fee = ds~load_uint(32);
        agreement_percent_numerator = ds~load_uint(32);
        agreement_percent_denominator = ds~load_uint(32);
        pending_invitations = ds~load_dict();
        pending_transactions = ds~load_dict();
        authorized_addresses = ds~load_dict();
        total_approval_points = ds~load_uint(32);
        total_distribution_points = ds~load_uint(32);
    ds.end_parse();
}

() save_data() impure inline {

    set_data(
        begin_cell()
            .store_slice(root_address)
            .store_uint(deployer_address_sha256, 256)
            .store_uint(transaction_fee, 32)
            .store_uint(agreement_percent_numerator, 32)
            .store_uint(agreement_percent_denominator, 32)
            .store_dict(pending_invitations)
            .store_dict(pending_transactions)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_distribution_points, 32)
        .end_cell()
    );
}

() clear_pending_transactions_queue(cell pending_transactions) inline {

    (int key, slice value, int success?) = pending_transactions.udict_get_min?(256);

    while (success?) {
        (key, value, success?) = pending_transactions.udict_get_next?(256, key);

        value~skip_bits(8); ;; skip transaction_type
        value~load_uint(32); ;; deadline
    }

}

(int) check_authority(slice sender_address, int address_index) inline {

    (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);

    if (equal_slices(sender_address, address_info~load_msg_addr())) {
        return true;
    } else {
        return false;
    }
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::approve_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);
        int transaction_index = in_msg_body~load_uint(8);

        ;; get transaction by transaction_index

        (slice transaction, int found?) = pending_transactions.udict_get?(8, transaction_index);
        throw_unless(200, found?);

        ;; Parse transaction

        int transaction_type = transaction~load_uint(4); ;; transaction_type
        int deadline = transaction~load_uint(32); ;; deadline
        cell transaction_info = transaction~load_ref(); ;; transaction_info
        cell approves = transaction~load_ref(); ;; approves
        int approve_points = transaction~load_uint(32); ;; approve_points

        ;; add approve

        int success? = approves~udict_add?(8, address_index, transaction);

        ;; get info about address from authorized_addresses

        (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);
        throw_unless(111, success?); ;; throw if there is not such a address

        slice address = address_info~load_msg_addr();
        int approval_points = address_info~load_uint(32);
        int distribution_points = address_info~load_uint(32);

        ;; Calculate new total transaction

        int new_approve_points = approve_points + approval_points;

        int approves_for_approval = total_approval_points / agreement_percent_denominator * agreement_percent_numerator;

        ;; Do pending_transactions in case of approval, otherwise save approve

        if (new_approve_points > approves_for_approval) {

            slice transaction_info_cs = transaction_info.begin_parse();

            ;; Do pending_transactions

            if (transaction_type == tt::invite_address) {

                (int last_address_index, _, _) = pending_transactions.udict_get_max?(8);
                int new_address_index = last_address_index + 1;

                transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                transaction_info_cs~load_uint(32); ;; int distribution_points

                ;; Add new address to dict

                authorized_addresses~udict_add?(8, new_address_index, transaction_info_cs);

                ;; Increase total approves

                total_approval_points += approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::delete_address) {

                int address_to_delete_index = transaction_info_cs~load_uint(8);

                ;; Delete address from dict

                authorized_addresses.udict_delete?(8, address_to_delete_index);

                ;; Decrease total approves

                total_approval_points -= approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::distribute_ton) {

                int ton_to_route = transaction_info_cs~load_uint(32); ;; int amount

                ;; Route ton

                (int key, slice value, int success?) = authorized_addresses.udict_get_min?(64);

                while (success?) {

                    slice address = address_info~load_msg_addr();
                    int approval_points = address_info~load_uint(32);
                    int distribution_points = address_info~load_uint(32);

                    int ton_amount_to_address = ton_to_route / total_distribution_points * distribution_points;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(ton_amount_to_address)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);
                }

                save_data();
                return ();

            }

            if (transaction_type == tt::arbitrary_transaction) {

                slice destination = transaction_info_cs~load_msg_addr(); ;; destination
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body

                ;; Arbitrary transtransaction

                var msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(destination)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();
                send_raw_message(msg, 0);

                save_data();
                return ();

            }

            if (transaction_type == tt::update_agreement_percent) {

                agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; parse and save new settings
                agreement_percent_denominator = transaction_info_cs~load_uint(32);

                save_data();
                return ();

            }

        } else {

            approves~udict_add?(8, transaction_index, transaction);
        }

    }

    ;; start transaction msg: int address_index, int transaction_index, cell transaction_cell

    if (op == op::propose_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        int transaction_index = in_msg_body~load_uint(8);
        cell transaction_cell = in_msg_body~load_ref();

        slice transaction_cell_cs = transaction_cell.begin_parse();

        ;; Check transaction info

        int transaction_type = transaction_cell_cs.preload_uint(4);
        int deadline = transaction_cell_cs.preload_uint(32);
        cell transaction_info = transaction_cell_cs.preload_ref();
        cell approves = transaction_cell_cs.preload_ref();
        int approve_points = transaction_cell_cs.preload_uint(32);

        slice transaction_info_cs = transaction_info.begin_parse();

        ;; Index 0: Add address
        ;; transaction_info: slice address_to_add_addr

        if (transaction_type == tt::invite_address) {

            ;; Check transaction_info for initiating adding address

            transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int distribution_points

            pending_transactions.udict_add?(10, transaction_index, transaction_cell.begin_parse());

            save_data();
            return ();

        }

        ;; Index 1: Eliminate address
        ;; transaction_info: slice address_to_eliminate_addr

        if (transaction_type == tt::delete_address) {

            ;; Check transaction_info for initiating termination of authority

            transaction_info_cs~load_msg_addr(); ;; slice address_to_eliminate_addr

            pending_transactions.udict_add?(10, transaction_index, transaction_cell.begin_parse());

            save_data();
            return ();

        }

        ;; Index 2: ton routing transaction
        ;; transaction_info: int amount

        if (transaction_type == tt::distribute_ton) {

            ;; Check transaction_info for initiating ton routing

            transaction_info_cs~load_uint(32); ;; int amount

            pending_transactions.udict_add?(10, transaction_index, transaction_cell.begin_parse());

            save_data();
            return ();

        }

        ;; Index 3: Arbitrary transtransaction
        ;; transaction_info: slice destination, int amount, cell msg_body

        if (transaction_type == tt::arbitrary_transaction) {

            ;; Check transaction_info for proposing arbitrary transtransaction

            transaction_info_cs~load_msg_addr(); ;; destination
            transaction_info_cs~load_uint(32); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body

            pending_transactions.udict_add?(10, transaction_index, transaction_cell.begin_parse());

            save_data();
            return ();

        }

        ;; Index 4: start change settings
        ;; transaction_info: 

        if (transaction_type == tt::update_agreement_percent) {

            ;; Check transaction_info for proposing of changing of transaction approval percent

            agreement_percent_numerator = transaction_info_cs~load_uint(32); ;; agreement_percent_numerator
            agreement_percent_denominator = transaction_info_cs~load_uint(32); ;; agreement_percent_denominator

            pending_transactions.udict_add?(10, transaction_index, transaction_cell.begin_parse());

            save_data();
            return ();

        }

    }

    if (op == op::accept_invitation_to_routing_pool) {

    }

    if (op == op::quit_routing_pool) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        authorized_addresses.udict_delete?(8, address_index);

        save_data();
        return ();

    }

    if (op == op::process_deploy_message) {

        throw_unless(666, equal_slices(sender_address, root_address));

        ;; Add config immediately or add config later

    }

    if (op == op::activate_routing_pool) {

        throw_unless(333, equal_slices(sender_address, root_address));

        agreement_percent_numerator = in_msg_body~load_uint(32);
        agreement_percent_denominator = in_msg_body~load_uint(32);
        pending_invitations = in_msg_body~load_dict();

        ;; Send invites to routing pool

        (int key, slice val, int flag) = pending_invitations.udict_get_min?(256);
        while (flag) {

            slice address = val~load_msg_addr();
            int approval_points = val~load_uint(32);
            int distribution_points = val~load_uint(32);

            cell msg = 
                begin_cell()
                    .store_uint(0x10, 6)
                    .store_slice(address)
                    .store_coins(30000000) ;; check on tests
                    .store_uint(0, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(approval_points, 32)
                            .store_uint(distribution_points, 32)
                            .store_uint(0, 32)
                            .store_slice("You are invited to a routing pool. Please accept invitation by sending any response transaction. Please check root address of the routing pool is root.ton")
                        .end_cell()
                    )
                .end_cell();

            send_raw_message(msg, 0);

            (key, val, flag) = pending_invitations.udict_get_next?(256, key);

            active? = true;
            
        }

        save_data();
        return ();

    }

    throw(0xffff);

}

;; Custom get-methods

(slice, int, int, int, int, cell, cell, cell, int, int) get_routing_pool_data() {

    load_data();

    return (
        root_address,
        deployer_address_sha256,
        transaction_fee,
        agreement_percent_numerator, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
        agreement_percent_denominator,
        pending_invitations,
        pending_transactions,
        authorized_addresses,
        total_approval_points, ;; key: uint10 // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approve_points
        total_distribution_points ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
    );

}

;; NFT Get-Methods

(int, int, slice, slice, cell) get_nft_data() method_id {
  load_data();
  return (active?, deployer_address_sha256, root_address, begin_cell().end_cell().begin_parse(), begin_cell().end_cell());
}