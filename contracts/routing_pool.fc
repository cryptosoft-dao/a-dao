#include "imports/stdlib.fc";

;; Operation codes

const int op::process_deploy_message = 0;
const int op::change_transaction_approval_percent = 1
const int op::change_transaction_approval_percent = 2;
const int op::propose_transaction = 3;
const int op::approve_transaction = 4;
const int op::quit_routing_pool = 5;

;; Transaction types

const int tt::invite_address = 0;
const int tt::exclude_address = 1;
const int tt::distribute_ton = 2;
const int tt::arbitrary_transaction = 3;
const int tt::change_transaction_approval_percent = 4;

;; Storage globals

global slice root_address; ;; slice 257bits ;; initial state
global slice deployer_address_256; ;; slice 257bits ;; initial state
global int transaction_fee;
global int transaction_approval_percent; ;; int8 ;; on activation
global cell pending_invitations; ;; on activation
;; dict authorized_addresses
    ;; Key: uint256 address_sha256_hash
    ;; Value (cell)
        ;; slice address
        ;; int32 approval_points
        ;; int32 distribution_points
;; dict pending_transactions
    ;; Key: uint256 address_sha256_hash
    ;; Value (cell)
        ;; int4 transaction_type
        ;; int32 deadline
        ;; cell transaction_info
        ;; cell approves
        ;; int32 approve_points
global cell pending_transactions;
;; dict pending_invitations
    ;; Key:
    ;; Value
    ;; int transaction_type
    ;; int deadline
    ;; cell transaction_info
    ;; cell approves
    ;; int approve_points
global int authorized_addresses;
global int total_approval_points;
global int total_distribution_points;

;; Storage functions

() load_data() impure inline { 

    slice ds = get_data().begin_parse();
        root_address = ds~load_msg_addr();
        deployer_address = ds~load_msg_addr();
        config = ds~load_ref();
        fees_info = ds~load_ref();
        referral_program = ds~load_ref();
        fees_info = ds~load_ref();
    ds.end_parse();
}

() save_data() impure inline {

    set_data(
        begin_cell()
            .store_slice(deployer_address)
            .store_uint(max_authorized_addresses, 8)
            .store_uint(transaction_approval_percent, 8)
            .store_dict(authorized_addresses)
            .store_uint(total_approval_points, 32)
            .store_uint(total_distribution_points, 32)
            .store_dict(pending_transactions)
            .store_dict(pending_invitations)
        .end_cell()
    );
}

;; Cell-parsing functions

() parse_config(cell config) impure {
    config_cs = config.begin_parse();
    max_authorized_addresses = config_cs~load_int(8);
    transaction_approval_percent = config_cs~load_int(8);
    max_pending_transactions = config_cs~load_int(8);
    max_pending_invitations = config_cs~load_int(8);
}

() parse_fees_info(cell fees_info) impure {
    fees_info_cs = fees_info.begin_parse();
    creation_blockchain_fee = fees_info_cs~load_uint(32);
    creation_protocol_fee = fees_info_cs~load_uint(32);
    transaction_blockchain_fee = fees_info_cs~load_uint(32);
    transaction_protocol_fee = fees_info_cs~load_uint(32);
}

() parse_refferal_program(cell refferal_program) impure {
    fees_info_cs = refferal_program.begin_parse();
    max_referal_level = fees_info_cs~load_uint(3);
    creation_fee_discount_numerator = fees_info_cs~load_uint(32);
    creation_fee_discount_denominator = fees_info_cs~load_uint(32);
    transaction_fee_discount_numerator = fees_info_cs~load_uint(32);
    transaction_fee_discount_denominator = fees_info_cs~load_uint(32);
}

() parse_main(cell main_data) impure {
    cs = main_data.begin_parse();
    return (
        cs~load_dict(), ;; dict authorized_addresses
        cs~load_uint(), ;; uint32 total_approval_points
        cs~load_uint(), ;; uint32 total_distribution_points
        cs~load_dict(), ;; dict pending_transactions
        cs~load_dict() ;; dict pending_invitations
    );
}

() clear_pending_transactions_queue() inline {

    (int key, slice value, int success?) = pending_transactions.udict_get_min?(256);

    while (success?) {
        (key, value, success?) = pending_transactions.udict_get_next?(256, key);

        value~skip_bits(8); ;; skip transaction_type
        value~load_uint(32); ;; deadline
    }
}

() add_cached_transaction() inline {

    (int key, slice value, int success?) = udict_get_max?(pending_transactions, 64);

    if (key = 255) {
        clear_pending_transactions_queue(pending_transactions);
    }

    if (success?) {
        pending_transactions~udict_add?(64, key + 1, cached_transaction);
    }
}

(int) check_authority(slice sender_address, int address_index) inline {

    (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);

    if (equal_slices(sender_address, address_info~load_msg_addr())) {
        return true;
    } else {
        return false;
    }
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::approve_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);
        int transaction_index = in_msg_body~load_uint(8);

        ;; get transaction by transaction_index

        (slice transaction, int found?) = pending_transactions.udict_get?(8, transaction_index);
        throw_unless(200, found?);

        ;; Parse transaction

        int transaction_type = transaction~load_uint(4); ;; transaction_type
        int deadline = transaction~load_uint(32); ;; deadline
        cell transaction_info = transaction~load_ref(); ;; transaction_info
        cell approves = transaction~load_ref(); ;; approves
        int approve_points = transaction~load_uint(32); ;; approve_points

        ;; add approve

        int success? = approves~udict_add?(8, address_index, transaction);

        ;; get info about address from authorized_addresses

        (slice address_info, int success?) = authorized_addresses.udict_get?(8, address_index);
        throw_unless(111, success?); ;; throw if there is not such a address

        slice address = address_info~load_msg_addr();
        int approval_points = address_info~load_uint(32);
        int distribution_points = address_info~load_uint(32);

        ;; Calculate new total transaction

        int new_approve_points = approve_points + approval_points;

        ;; Parse settings

        slice settings_cs = settings.begin_parse();
        int max_authorized_addresses = settings_cs~load_uint(8); ;; skip 
        int agreement_percent = settings_cs~load_uint(8);

        int approves_for_approval = agreement_percent / total_credits * 100;

        ;; Do pending_transactions in case of approval, otherwise save approve

        if (new_approve_points > approves_for_approval) {

            slice transaction_info_cs = transaction_info.begin_parse();

            ;; Do pending_transactions

            if (transaction_type == tt::add_address) {

                (int last_address_index, _, _) = pending_transactions.udict_get_max?(8);
                int new_address_index = last_address_index + 1;

                transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
                int approval_points = transaction_info_cs~load_uint(32);
                transaction_info_cs~load_uint(32); ;; int distribution_points

                ;; Add new address to dict

                if (new_address_index < max_authorized_addresses) {
                    authorized_addresses~udict_add?(8, new_address_index, transaction_info_cs);
                }

                ;; Increase total approves

                total_credits += approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::delete_address) {

                int address_to_delete_index = transaction_info_cs~load_uint(8);

                ;; Delete address from dict

                authorized_addresses.udict_delete?(8, address_to_delete_index);

                ;; Decrease total approves

                total_credits -= approval_points;

                save_data();
                return ();

            }

            if (transaction_type == tt::withdraw_ton) {

                int ton_to_route = transaction_info_cs~load_uint(32); ;; int amount

                ;; Route ton

                (int key, slice value, int success?) = authorized_addresses.udict_get_min?(64);

                while (success?) {

                    slice address = address_info~load_msg_addr();
                    int approval_points = address_info~load_uint(32);
                    int distribution_points = address_info~load_uint(32);

                    int address_ton = ton_to_route / total_credits * approval_points;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(address)
                        .store_coins(address_ton)
                        .store_uint(0, 107)
                        .end_cell();
                    send_raw_message(msg, 0);
                }

                save_data();
                return ();

            }

            if (transaction_type == tt::arbitrary_transaction) {

                slice destination = transaction_info_cs~load_msg_addr(); ;; destination
                int amount = transaction_info_cs~load_uint(32); ;; amount
                cell msg_body = transaction_info_cs~load_ref(); ;; msg_body

                ;; Arbitrary transtransaction

                var msg = begin_cell()
                        .store_uint(0x18, 6)
                        .store_slice(destination)
                        .store_coins(amount)
                        .store_uint(1, 107)
                        .store_ref(msg_body)
                    .end_cell();
                send_raw_message(msg, 0);

                save_data();
                return ();

            }

            if (transaction_type == tt::set_up) {

                settings = transaction_info_cs~load_ref(); ;; parse and save new settings

                save_data();
                return ();

            }

        } else {

            approves~udict_add?(8, transaction_index, transaction);
        }

    }

    ;; start transaction msg: int address_index, int transaction_index, cell transaction_cell

    if (op == op::propose_transaction) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        int transaction_index = in_msg_body~load_uint(8);
        cell transaction_cell = in_msg_body~load_ref();

        slice transaction_cell_cs = transaction_cell.begin_parse();

        ;; Check transaction info

        int transaction_type = transaction_cell_cs.preload_uint(4);
        int deadline = transaction_cell_cs.preload_uint(32);
        cell transaction_info = transaction_cell_cs.preload_ref();
        cell approves = transaction_cell_cs.preload_ref();
        int approve_points = transaction_cell_cs.preload_uint(32);

        slice transaction_info_cs = transaction_info.begin_parse();

        ;; Index 0: Add address
        ;; transaction_info: slice address_to_add_addr

        if (transaction_type == tt::add_address) {

            ;; Check transaction_info for initiating adding address

            transaction_info_cs~load_msg_addr(); ;; slice address_to_add_addr
            transaction_info_cs~load_uint(32); ;; int approval_points
            transaction_info_cs~load_uint(32); ;; int distribution_points

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 1: Eliminate address
        ;; transaction_info: slice address_to_eliminate_addr

        if (transaction_type == tt::delete_address) {

            ;; Check transaction_info for initiating termination of authority

            transaction_info_cs~load_msg_addr(); ;; slice address_to_eliminate_addr

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 2: ton routing transaction
        ;; transaction_info: int amount

        if (transaction_type == tt::withdraw_ton) {

            ;; Check transaction_info for initiating ton routing

            transaction_info_cs~load_uint(32); ;; int amount

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 3: Arbitrary transtransaction
        ;; transaction_info: slice destination, int amount, cell msg_body

        if (transaction_type == tt::random_transaction) {

            ;; Check transaction_info for initiating arbitrary transtransaction

            transaction_info_cs~load_msg_addr(); ;; destination
            transaction_info_cs~load_uint(32); ;; amount
            transaction_info_cs~load_ref(); ;; msg_body

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

        ;; Index 4: start change settings
        ;; transaction_info: 

        if (transaction_type == tt::set_up) {

            ;; Check transaction_info for changing settings

            transaction_info_cs~load_uint(8); ;; agreement_percent

            add_cached_transaction(pending_transactions, transaction_cell);

            save_data();
            return ();

        }

    }

    if (op == op::accept_invitation_to_routing_pool) {

    }

    if (op == op::quit_contract) {

        ;; Check if sender is an authorized routing pool wallet

        int address_index = in_msg_body~load_uint(8);

        check_authority(sender_address, address_index);

        authorized_addresses.udict_delete?(8, address_index);

        save_data();
        return ();

    }

    if (op == process_deploy_message) {

        throw_unless(666, sender_address == root_address);

        ;; Add config immediately or add config later

    }

    if (op == op::activate_routing_pool) {

        throw_unless(333, equal_slices?(sender_address, routing_pool_of_routing_pools_addr))
        throw_unless(666, get_data().begin_parse().slice_empty());

        max_authorized_addresses = in_msg_body~load_uint(8);
        transaction_approval_percent = in_msg_body~load_uint(8);

        approval_points = in_msg_body~load_uint(8);
        distribution_points = in_msg_body~load_uint(8);

        max_authorized_addresses = in_msg_body~load_uint(8);
        agreement_percent = in_msg_body~load_uint(8);
        authorized_addresses = new_dict();

        total_approval_points = 0;
        total_distribution_points = 0;
        pending_transactions = new_dict();
        pending_invitations = 

        ;; Send invites to routing pool

        save_data();
        return ();

    }

    if (op == op::update_approval_percent) {

    }

    throw(0xffff);

}

;; Custom get-methods

() get_routing_pool_data() {

    load_data();

    return (
        deployer_address_sha256,
        max_authorized_addresses,
        transaction_approval_percent,
        authorized_addresses, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
        total_approval_points,
        total_distribution_points,
        pending_transactions, ;; key: int address_sha256_hash // value (cell): int transaction_type, int deadline, cell transaction_info, cell approves, int approve_points
        pending_invitations, ;; key: int address_sha256_hash // value (cell): slice address,  int approval_points, int distribution_points
    );

}

;; NFT Get-Methods

(int, int, slice, slice, cell) get_nft_data() method_id {
  (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
  return (init?, index, collection_address, owner_address, content);
}