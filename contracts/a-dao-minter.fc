#include "stdlib.fc";
#include "op.fc";
#include "fees.fc";

;; Global variables

global slice owner_address;
global cell a_dao_code; ;; ref
global int total_a_daos; ;; uint32
global int next_a_dao_creation_fee; ;; uint32
global int next_a_dao_transaction_fee; ;; uint32

;; Storage functions

() load_data() impure inline {

    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    a_dao_code = ds~load_ref();
    total_a_daos = ds~load_uint(32);
    next_a_dao_creation_fee = ds~load_coins();
    next_a_dao_transaction_fee = ds~load_coins();
    ds.end_parse();

}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(owner_address)
            .store_ref(a_dao_code)
            .store_uint(total_a_daos, 32)
            .store_uint(next_a_dao_creation_fee, 32)
            .store_uint(next_a_dao_transaction_fee, 32)
        .end_cell()
    );
}

;; Functions

cell calculate_a_dao_initial_state(
        slice deployer_address,
        cell a_dao_code
    ) {
  cell a_dao_data = 
    begin_cell()
        .store_uint(0, 1) ;; int1 active?
        .store_slice(my_address()) ;; slice root_address
        .store_slice(deployer_address)
    .end_cell();
  return (
    begin_cell()
        .store_uint(0, 2)
        .store_dict(a_dao_code)
        .store_dict(a_dao_data)
        .store_uint(0, 1)
    .end_cell()
  );
}

slice calculate_a_dao_address(cell a_dao_initial_state) {
  return 
    begin_cell()
        .store_uint(4, 3)
        .store_int(0, 8)
        .store_uint(cell_hash(a_dao_initial_state), 256)
    .end_cell()
    .begin_parse();
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure inline {

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    load_data();

    if (in_msg_body.slice_empty?()) {

        throw_unless(666, msg_value > next_a_dao_creation_fee);

        ;; Deploy routing pool

        cell a_dao_initial_state = calculate_a_dao_initial_state(sender_address, a_dao_code);
        slice a_dao_address = calculate_a_dao_address(a_dao_initial_state);

        cell message = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(a_dao_address)
            .store_coins(50000000)
            .store_uint(7, 108)
            .store_ref(a_dao_initial_state)
            .store_ref(
                begin_cell()
                    .store_uint(op::process_deploy_message, 32)
                    .store_uint(next_a_dao_transaction_fee, 32)
                .end_cell()
            )
        .end_cell();

        send_raw_message(message, 0);

        return ();
        
    }

    int op = in_msg_body~load_uint(32);

    if (op == op::change_a_dao_minter_owner) {

        throw_unless(666, equal_slices(sender_address, owner_address));
        owner_address = in_msg_body~load_msg_addr();

        save_data();

    }

}

;; Custom get-methods

(slice) get_a_dao_address_by_deployer_address(slice deployer_address) method_id {
    load_data();
    return calculate_a_dao_address(calculate_a_dao_initial_state(deployer_address, a_dao_code));
}

(int) get_total_a_daos() {
    return total_a_daos;
}

(int) get_next_a_dao_creation_fee() method_id {
    return next_a_dao_creation_fee;
}

(int) get_next_routing_pool_index() method_id {
    return total_a_daos + 1;
}