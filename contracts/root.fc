#include "imports/stdlib.fc";

const int op::create_routing_pool = 0;
const int op::activate_routing_pool = 1;

global int blockchain_fee;
global int protocol_fee;
global int referal_discount_denominator;

global cell routing_pool_code;

cell calculate_routing_pool_routing_pool_initial_state(int routing_pool_index, cell routing_pool_code) {
  cell routing_pool_data = begin_cell().store_uint(routing_pool_index, 64).store_slice(my_address()).end_cell();
  return (
    begin_cell()
        .store_dict(routing_pool_code)
        .store_dict(routing_pool_data)
    .end_cell()
  );
}

slice calculate_routing_pool_address(int workchain, cell routing_pool_initial_state) {
  return 
    begin_cell()
        .store_uint(4, 3)
        .store_int(workchain, 8)
        .store_uint(cell_hash(routing_pool_initial_state), 256)
    .end_cell()
    .begin_parse();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure inline {

    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op::create_routing_pool) {

        referal? = in_msg_body~load_uint(1);
        approval_points = in_msg_body~load_uint(8);
        distribution_points = in_msg_body~load_uint(8);

        max_authorized_addresses = in_msg_body~load_uint(8);
        agreement_percent = in_msg_body~load_uint(8);
        routing_pool_invitations = in_msg_body-load_dict();

        cell routing_pool_initial_state = calculate_routing_pool_routing_pool_initial_state(deployer_address, routing_pool_code);
        slice routing_pool_address = calculate_routing_pool_address(workchain(), routing_pool_initial_state);

        cell message = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to)
            .store_coins(amount)
            .store_uint(7, 108)
            .store_ref(routing_pool_initial_state)
            .store_ref(
                begin_cell()
                    .store_uint(op::activate_routing_pool, 32)
                    .store_slice(deployer_address)
                    .store_uint(approval_points, 8)
                    .store_uint(distribution_points, 8)
                    .store_uint(max_authorized_addresses, 8)
                    .store_uint(agreement_percent, 8)
                    .store_dict(authorized_addresses)
                    .store_uint(total_approval_points, 32)
                    .store_uint(total_distribution_points, 32)
                .end_cell()
            )
        .end_cell();

        send_raw_message(message, 0);

    }

}

() recv_external() impure inline {

    if ()

}

slice get_routing_pool_address_by_deployer_address (slice deployer_address) method_id {
    var (_, _, _, nft_item_code, _) = load_data();
    cell routing_pool_initial_state = calculate_nft_item_routing_pool_initial_state(index, nft_item_code);
    return calculate_nft_item_address(0, routing_pool_initial_state);
}