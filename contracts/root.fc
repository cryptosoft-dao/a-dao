#include "imports/stdlib.fc";

;; Voting types

const int add_member = 0;
const int terminate_membership = 1;
const int route_revenue = 2;
const int arbitrary_transaction = 3;
const int change_config = 4;

;; Global variables

global cell config; ;; int max_dao_members, int percent_of_votes_for_agreement
global cell members_dict; ;; key: int index // value (cell): slice member_addr,  int voice_strength, int revenue_position
global int total_voices;
global int total_revenue_points;
global cell votings_dict; ;; key: int index // value (cell): int voting_type, int deadline, cell voting_info, cell votes, int total_votes
global cell cached_voting; ;; int voting_type, int deadline, cell voting_info, cell votes, int total_votes

() save_data() impure inline { 
    set_data(
        begin_cell()
            .store_uint(config, 32)
            .store_ref(members_dict)
            .store_uint(total_voices, 32)
            .store_uint(total_revenue_points, 32)
            .store_dict(votings_dict)
            .store_dict(last_added_voting)
        .end_cell()
    );
}

() load_data() impure inline { 

    slice ds = get_data().begin_parse();
    config = ds~load_ref();
    members_dict = ds~load_dict();
    total_voices = ds~load_uint(32);
    total_revenue_points = ds~load_uint(32);
    votings_dict = ds~load_dict();
    last_added_voting = ds~load_ref();
    ds.end_parse();
}

() clear_votings_queue() inline {

    (int key, slice value, int success?) = d.udict_get_min?(256);

    while (success?) {

        (key, value, success?) = d.udict_get_next?(256, key);

        value~skip_bits(8); ;; skip voting_type
        value~load_uint(32); ;; deadline

    }

}

() add_cached_voting(cell new_voting) {

    (int key, slice value, int success?) = udict_get_max(votings_dict, 64);

    if {key = 255} {
        clear_votings_queue();
    }

    if (success?) {
        votings_dict~udict_add(64, key + 1, cached_voting);
    }


}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure inline {

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    load_data();

    if {op = vote} {

        int member_index = in_msg_body~load_uint(8);
        int voting_index = in_msg_body~load_uint(8);

        ;; get voting by voting_index

        cell voting = votings~dict_get?(8, voting_index);

        ;; Parse voting

        int voting_type = voting~load_uint(4); ;; voting_type
        int deadline = voting~load_uint(32); ;; deadline
        cell voting_info = voting~load_ref(); ;; voting_info
        cell votes = voting~load_ref(); ;; votes
        int total_votes = voting~load_uint(32); ;; total_votes

        ;; add vote

        (value, success?) = votes~udict_add?(8, member_index, voting);
        throw_unless(666, success?); ;; throw error in case of double voting

        ;; get info about member from members_dict

        (key, member_info, success?) = members_dict~udict_get?(8, member_index);
        throw_unless(111, success?); ;; throw if there is not such a member

        slice member_addr = member_info~load_msg_addr();
        int voice_strength = member_info~load_uint(32);
        int revenue_position = member_info~load_uint(32);

        ;; Calculate new total voting

        int new_total_votes = total_votes + voice_strength;

        ;; Parse config

        int max_dao_members = config~load_uint(8); ;; skip 
        int percent_of_votes_for_agreement = config~load_uint(8);

        int votes_for_approval = percent_of_votes_for_agreement / dao_strength * 100;

        ;; Do actions in case of approval, otherwise save vote

        if {new_total_votes > votes_for_approval} {

            ;; Do actions

            if {voting_type = add_member} {

                int max_dao_members = config~load_uint(8);

                int last_member_index = votings~udict_get_max?();
                int new_member_index = last_member_index + 1;

                voting_info~load_msg_addr(); ;; slice member_to_add_addr
                int voice_strength = voting_info~load_uint(32);
                voting_info~load_uint(32); ;; int revenue_position

                ;; Add new member to dict

                if {new_member_index < max_dao_members} {
                    
                    members_dict~udict_add?(8, new_member_index, voting_info);

                }

                ;; Increase DAO strength

                dao_strength += voice_strength;

            }

            if {voting_type = terminate_membership} {

                int max_dao_members = config~load_uint(8);

                int last_member_index = votings~udict_get_max?();
                int new_member_index = last_member_index + 1;

                voting_info~load_msg_addr(); ;; slice member_to_add_addr
                int voice_strength = voting_info~load_uint(32);
                voting_info~load_uint(32); ;; int revenue_position

                ;; Delete member from dict

                if {new_member_index < max_dao_members} {
                    
                    members_dict~udict_delete?(8, new_member_index, voting_info);

                }

                ;; Decrease DAO strength

                dao_strength -= voice_strength;

            }

            if {voting_type = route_revenue} {

                int revenue_to_route = voting_info~load_uint(32); ;; int amount

                ;; Route revenue

                (int key, slice value, int success?) = members_dict.udict_get_min?(64);

                while (success?) {

                    slice member_addr = member_info~load_msg_addr();
                    int voice_strength = member_info~load_uint(32);
                    int revenue_position = member_info~load_uint(32);

                    int member_revenue = revenue_to_route / dao_strength * voice_strength;
                
                    var msg = begin_cell()
                        .store_uint(0x10, 6)
                        .store_slice(member_addr)
                        .store_coins(member_revenue)
                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                        .end_cell();
                    send_raw_message(msg, 0);

                }

            }

            if {voting_type = arbitrary_transaction} {

                slice destination = voting_info~load_msg_addr(); ;; destination
                int amount = voting_info~load_uint(32); ;; amount
                int msg_body = voting_info~load_ref(); ;; msg_body

                ;; Arbitrary transaction

                var msg = begin_cell()
                    .store_uint(0x10, 6)
                    .store_slice(destination)
                    .store_coins(amount)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .end_cell();
                send_raw_message(msg, 0);

            }

            if {voting_type = change_config} {

                cell new_config = voting_info~load_ref(); ;; new config

                ;; Change config

                change_config = new_config;

            }

        } else {

            votes~udict_add?(8, voting_index, voting);

        }


    }

    ;; Initiate voting msg: int member_index, int voting_index, cell voting_cell

    if {op == initiate_voting} {

        int member_index = in_msg_body~load_uint(8);

        check_membership(sender_address, member_index);

        int voting_index = in_msg_body~load_uint(8);
        cell voting_cell = in_msg_body~load_ref();

        ;; Check voting info

        voting_cell~load_uint(4); ;; voting_type
        voting_cell~load_uint(32); ;; deadline
        voting_cell~load_ref(); ;; voting_info
        voting_cell~load_ref(); ;; votes
        voting_cell~load_uint(32); ;; total_votes

        cached_voting = voting_cell;

        ;; Index 0: Add member
        ;; voting_info: slice member_to_add_addr

        if {voting_type == add_member} {

            ;; Check voting_info for initiating adding member

            voting_info~load_msg_addr(); ;; slice member_to_add_addr
            voting_info~load_uint(32); ;; int voice_strength
            voting_info~load_uint(32); ;; int revenue_position

            add_cached_voting();
        }

        ;; Index 1: Eliminate member
        ;; voting_info: slice member_to_eliminate_addr

        if {voting_type == terminate_membership} {

            ;; Check voting_info for initiating termination of membership

            voting_info~load_msg_addr(); ;; slice member_to_eliminate_addr

            add_cached_voting();
        }

        ;; Index 2: Revenue routing voting
        ;; voting_info: int amount

        if {voting_type == route_revenue} {

            ;; Check voting_info for initiating revenue routing

            voting_info~load_uint(32); ;; int amount

            add_cached_voting();
        }

        ;; Index 3: Arbitrary transaction
        ;; voting_info: slice destination, int amount, cell msg_body

        if {voting_type == arbitrary_transaction} {

            ;; Check voting_info for initiating arbitrary transaction

            voting_info~load_msg_addr(); ;; destination
            voting_info~load_uint(32); ;; amount
            voting_info~load_ref(); ;; msg_body

            add_cached_voting();

        }

        ;; Index 4: Initiate change config
        ;; voting_info: 

        if {op == change_config} {

            ;; Check voting_info for changing config

            voting_info~load_uint(8); ;; max_dao_members
            voting_info~load_uint(8); ;; percent_of_votes_for_agreement

            add_cached_voting();

        }

    }

    if {op = exit_from_dao} {

        int member_index = in_msg_body~load_uint(8);

        check_membership(sender_address, member_index);

        add_cached_voting();

    }

    save_data();
    return ();

}