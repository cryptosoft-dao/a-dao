#include "imports/stdlib.fc";

;; Internal operation codes

const int op::change_root_owner = 0;

;; External operation codes

const int op::process_deploy_message = 0;

;; Global variables

global slice owner_address;
global cell routing_pool_code; ;; ref
global int total_routing_pools; ;; uint32
global int next_routing_pool_creation_fee; ;; uint32
global int next_routing_pool_transaction_fee; ;; uint32

;; Fees constants

const int next_routing_pool_creation_fee_discount = 10000; ;; amount in nanotons
const int next_routing_pool_transaction_fee_increase = 1000000; ;; amount in nanotons
const int max_routing_pool_transaction_fee = 1000000000; ;; amount in nanotons

;; Storage functions

() load_data() impure inline {

    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    routing_pool_code = ds~load_ref();
    total_routing_pools = ds~load_uint(32);
    next_routing_pool_creation_fee = ds~load_coins();
    next_routing_pool_transaction_fee = ds~load_coins();
    ds.end_parse();

}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(owner_address)
            .store_ref(routing_pool_code)
            .store_uint(total_routing_pools, 32)
            .store_uint(next_routing_pool_creation_fee, 32)
            .store_uint(next_routing_pool_transaction_fee, 32)
        .end_cell()
    );
}

;; Functions

cell calculate_routing_pool_initial_state(
        int deployer_address_sha256,
        cell routing_pool_code
    ) {
  cell routing_pool_data = 
    begin_cell()
        .store_uint(0, 1) ;; int1 active?
        .store_slice(my_address()) ;; slice root_address
        .store_uint(deployer_address_sha256, 256)
    .end_cell();
  return (
    begin_cell()
        .store_uint(0, 2)
        .store_dict(routing_pool_code)
        .store_dict(routing_pool_data)
        .store_uint(0, 1)
    .end_cell()
  );
}

slice calculate_routing_pool_address(cell routing_pool_initial_state) {
  return 
    begin_cell()
        .store_uint(4, 3)
        .store_int(0, 8)
        .store_uint(cell_hash(routing_pool_initial_state), 256)
    .end_cell()
    .begin_parse();
}

() main(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure inline {

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (flags & 1) {  ;; ignore bounced messages
        return ();
    }

    load_data();

    if (in_msg_body.slice_empty?()) {

        throw_unless(666, msg_value > next_routing_pool_creation_fee);

        ;; Deploy routing pool

        cell routing_pool_initial_state = calculate_routing_pool_initial_state(cell_hash(begin_cell().store_slice(sender_address).end_cell()), routing_pool_code);
        slice routing_pool_address = calculate_routing_pool_address(routing_pool_initial_state);

        cell message = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(routing_pool_address)
            .store_coins(50000000)
            .store_uint(7, 108)
            .store_ref(routing_pool_initial_state)
            .store_ref(
                begin_cell()
                    .store_uint(op::process_deploy_message, 32)
                    .store_uint(next_routing_pool_transaction_fee, 32)
                .end_cell()
            )
        .end_cell();

        send_raw_message(message, 0);

        return ();
        
    }

    int op = in_msg_body~load_uint(32);

    if (op == op::change_root_owner) {

        throw_unless(666, equal_slices(sender_address, owner_address));
        owner_address = in_msg_body~load_msg_addr();

        save_data();

    }

}

;; Custom get-methods

(int) get_total_routing_pools() {
    return total_routing_pools;
}

(int) get_next_routing_pool_creation_fee() method_id {
    return next_routing_pool_creation_fee;
}

(int) get_next_routing_pool_index() method_id {
    return total_routing_pools + 1;
}

slice get_routing_pool_address_by_deployer_address_sha256(int deployer_address_sha256) method_id {
    load_data();
    cell routing_pool_initial_state = calculate_routing_pool_initial_state(deployer_address_sha256, routing_pool_code);
    return calculate_routing_pool_address(routing_pool_initial_state);
}

;; Collection get-methods

(int, cell, slice) get_collection_data() method_id {
    return (
        total_routing_pools, 
        begin_cell().end_cell(), 
        owner_address
    );
}

slice get_nft_address_by_index(int deployer_address_sha256) method_id {
    cell referal_routing_pool_initial_state = calculate_routing_pool_initial_state(deployer_address_sha256, routing_pool_code);
    return calculate_routing_pool_address(referal_routing_pool_initial_state);
}

(int, int, slice) royalty_params() method_id {
     return (777, 777, owner_address);
}

cell get_nft_content(int index, cell individual_nft_content) method_id {
  return (begin_cell()
                      .store_uint(1, 8) ;; offchain tag
                      .store_slice(begin_cell().end_cell().begin_parse())
                      .store_ref(begin_cell().end_cell())
          .end_cell());
}